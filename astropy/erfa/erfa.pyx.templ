# "erfa.pyx" is auto-generated by cython_generator.py from the template 
# "erfa.pyx.templ". Do *not* edit erfa.pyx directly, instead edit the template
# and run cython_generator.py from the source directory to update it.

"""
This module uses Cython to wrap the ERFA library in numpy-vectorized equivalents.

This is currently *not* part of the public Astropy API, and may change in the future.
"""


import warnings
from ..utils.exceptions import AstropyUserWarning

import numpy
cimport numpy

numpy.import_array()


__all__ = ['ErfaError', 'ErfaWarning',
           {{ funcs|map(attribute='pyname')|surround("'","'")|join(", ") }}, 'dt_eraASTROM']


#<---------------------------------Error-handling----------------------------->

class ErfaError(ValueError):
    """
    A class for errors triggered by ERFA functions (status codes < 0)
    """


class ErfaWarning(AstropyUserWarning):
    """
    A class for warnings triggered by ERFA functions (status codes > 0)
    """


STATUS_CODES = {}  # populated below before each function that returns an int

def check_errwarn(statcodes, func_name):
    if numpy.any(statcodes<0):
        # errors present - only report the errors.

        errcodes = numpy.unique(statcodes[statcodes<0])

        errcounts = dict([(e, numpy.sum(statcodes==e)) for e in errcodes])

        elsemsg = STATUS_CODES[func_name].get('else', None)
        if elsemsg is None:
            errmsgs = dict([(e, STATUS_CODES[func_name].get(e, 'Return code ' + str(e))) for e in errcodes])
        else:
            errmsgs = dict([(e, STATUS_CODES[func_name].get(e, elsemsg)) for e in errcodes])

        emsg = ', '.join(['{0} of "{1}"'.format(errcounts[e], errmsgs[e]) for e in errcodes])
        raise ErfaError('ERFA function "' + func_name + '" yielded ' + emsg)

    elif numpy.any(statcodes>0):
        #only warnings present
        warncodes = numpy.unique(statcodes[statcodes>0])

        warncounts = dict([(w, numpy.sum(statcodes==w)) for w in warncodes])

        elsemsg = STATUS_CODES[func_name].get('else', None)
        if elsemsg is None:
            warnmsgs = dict([(w, STATUS_CODES[func_name].get(w, 'Return code ' + str(w))) for w in warncodes])
        else:
            warnmsgs = dict([(w, STATUS_CODES[func_name].get(w, elsemsg)) for w in warncodes])

        wmsg = ', '.join(['{0} of "{1}"'.format(warncounts[w], warnmsgs[w]) for w in warncodes])
        warnings.warn('ERFA function "' + func_name + '" yielded ' + wmsg, ErfaWarning)


#<--------------------------Actual ERFA-wrapping code------------------------->

cdef extern from "erfa.h":
    struct eraASTROM:
        pass
    struct eraLDBODY:
        pass
{%- for func in funcs %}
    {{ func.ret }} {{ func.name }}({{ func.args_by_inout('in|inout|out')|map(attribute='ctype_ptr')|join(', ') }})
{%- endfor %}

dt_eraASTROM = numpy.dtype([('pmt','d'),
                         ('eb','d',(3,)),
                         ('eh','d',(3,)),
                         ('em','d'),
                         ('v','d',(3,)),
                         ('bm1 ','d'),
                         ('bpn','d',(3,3)),
                         ('along','d'),
                         ('phi','d'),
                         ('xpl','d'),
                         ('ypl','d'),
                         ('sphi','d'),
                         ('cphi','d'),
                         ('diurab','d'),
                         ('eral','d'),
                         ('refa','d'),
                         ('refb','d')], align=True)




{% for func in funcs %}
def {{ func.pyname }}({{ func.args_by_inout('in|inout')|map(attribute='name')|join(', ') }}):
    """
    {{ func.pyname }}({{ func.args_by_inout('in|inout')|map(attribute='name')|join(', ') }})

    Returns: {{ func.args_by_inout('inout|out|ret')|map(attribute='name')|postfix('_out')|join(', ') }}

    ERFA documentation:
    {{ func.doc }}
    """
    
    {%- if func.args_by_inout('in|inout') %}
    {%- if func.args_by_inout('in|inout')|map(attribute='name')|list|length < 2 %}
    in_shape = numpy.broadcast({{ func.args_by_inout('in|inout')|map(attribute='name')|first }}, 0).shape
    {%- else %}
    in_shape = numpy.broadcast({{ func.args_by_inout('in|inout')|map(attribute='name')|join(', ') }}).shape
    {%- endif %}
    {%- for arg in func.args_by_inout('out|ret|stat') %}
    {{ arg.name }}_out = numpy.empty(in_shape, dtype={{ arg.dtype }})
    {%- endfor %}
    {%- for arg in func.args_by_inout('inout') %}
    {{ arg.name }}_out = numpy.array(numpy.broadcast_arrays({{ func.args_by_inout('in|inout')|map(attribute='name')|join(', ') }})[{{ func.args.index(arg) }}], dtype={{ arg.dtype }})
    {%- endfor %}
    
    cdef numpy.broadcast it = numpy.broadcast({{ (func.args_by_inout('in')|map(attribute='name')|list + func.args_by_inout('inout|out|ret|stat')|map(attribute='name')|postfix('_out')|list) |join(', ') }})
    {%- for arg in func.args_by_inout('in|inout|out|ret|stat') %}
    cdef {{ arg.ctype_ptr }} _{{ arg.name }}
    {%- endfor %}
    {%- if func.args_by_inout('stat')|length > 0 %}
    cdef bint stat_ok = True
    {%- endif %}
    
    while numpy.PyArray_MultiIter_NOTDONE(it):
        
        {%- for arg in func.args_by_inout('in|inout|out') %}
        {%- if arg.ctype_ptr[-1] == '*' %}
        _{{ arg.name }} = (<{{ arg.ctype_ptr }}>numpy.PyArray_MultiIter_DATA(it, {{ func.args.index(arg) }}))
        {%- else %}
        _{{ arg.name }} = (<{{ arg.ctype_ptr }}*>numpy.PyArray_MultiIter_DATA(it, {{ func.args.index(arg) }}))[0]
        {%- endif %}
        {%- endfor %}
        
        {{ func.args_by_inout('ret|stat')|map(attribute='name')|surround('_',' = ')|join }}{{ func.name }}({{ func.args_by_inout('in|out|inout')|map(attribute='name')|prefix('_')|join(', ') }})
        
        {%- for arg in func.args_by_inout('ret|stat') %}
        (<{{ arg.ctype_ptr }}*>numpy.PyArray_MultiIter_DATA(it, {{ func.args.index(arg) }}))[0] = _{{ arg.name }}
        {%- if arg.inout_state == 'stat' %}
        if _{{ arg.name }} != 0:
            stat_ok = False
        {%- endif %}
        {%- endfor %}
        
        numpy.PyArray_MultiIter_NEXT(it)
    {%- else %}
    in_shape = ()
    {%- for arg in func.args_by_inout('out') %}
    {{ arg.name }}_out = numpy.empty(in_shape, dtype={{ arg.dtype }})
    {%- endfor %}
    
    cdef numpy.broadcast it = numpy.broadcast({{ (func.args_by_inout('in')|map(attribute='name')|list + func.args_by_inout('inout|out|ret')|map(attribute='name')|postfix('_out')|list) |join(', ') }})
    {%- for arg in func.args_by_inout('out') %}
    cdef {{ arg.ctype_ptr }} _{{ arg.name }}
    {%- endfor %}
    
    while numpy.PyArray_MultiIter_NOTDONE(it):
        
        {%- for arg in func.args_by_inout('in|inout|out') %}
        {%- if arg.ctype_ptr[-1] == '*' %}
        _{{ arg.name }} = (<{{ arg.ctype_ptr }}>numpy.PyArray_MultiIter_DATA(it, {{ func.args.index(arg) }}))
        {%- else %}
        _{{ arg.name }} = (<{{ arg.ctype_ptr }}*>numpy.PyArray_MultiIter_DATA(it, {{ func.args.index(arg) }}))[0]
        {%- endif %}
        {%- endfor %}
    
        {{ func.name }}({{ func.args_by_inout('in|out|inout')|map(attribute='name')|prefix('_')|join(', ') }})
        
        numpy.PyArray_MultiIter_NEXT(it)
    {%- endif %}
    
    {%- for stat in func.args_by_inout('stat') %}

    if not stat_ok:
        check_errwarn({{ stat.name }}_out, '{{ func.pyname }}')
    {%- endfor %}
    
    return {{ func.args_by_inout('inout|out|ret')|map(attribute='name')|postfix('_out')|join(', ') }}

{%- for stat in func.args_by_inout('stat') %}
{%- if stat.doc_info.statuscodes %}
STATUS_CODES['{{ func.pyname }}'] = {{ stat.doc_info.statuscodes|string }}
{% endif %}
{%- endfor %}
{% endfor %}
