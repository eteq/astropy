# Licensed under a 3-clause BSD style license - see LICENSE.rst

# "erfa.pyx" is auto-generated by cython_generator.py from the template 
# "erfa.pyx.templ". Do *not* edit erfa.pyx directly, instead edit the template
# and run cython_generator.py from the source directory to update it.

"""
This module uses Cython to wrap the ERFA library in numpy-vectorized
equivalents.

..warning::
    This is currently *not* part of the public Astropy API, and may change in
    the future.


The key idea is that any function can be called with inputs that are arrays,
and the wrappers will automatically vectorize and call the ERFA functions for
each item using broadcasting rules for numpy.  So the return values are always
numpy arrays of some sort.

For ERFA functions that take/return vectors or matricies, the vector/matrix
dimension(s) are always the *last* dimension(s).  For example, if you 
want to give ten matricies (i.e., the ERFA input type is double[3][3]),
you would pass in a (10, 3, 3) numpy array.  If the output of the ERFA 
function is scalar, you'll get back a length-10 1D array. 
"""
from __future__ import (absolute_import, division, print_function)

import warnings
from ..utils.exceptions import AstropyUserWarning

import numpy
cimport numpy

numpy.import_array()


__all__ = ['ErfaError', 'ErfaWarning',
           {{ funcs|map(attribute='pyname')|surround("'","'")|join(", ") }}, 'dt_eraASTROM']


#<---------------------------------Error-handling----------------------------->

class ErfaError(ValueError):
    """
    A class for errors triggered by ERFA functions (status codes < 0)
    """


class ErfaWarning(AstropyUserWarning):
    """
    A class for warnings triggered by ERFA functions (status codes > 0)
    """


STATUS_CODES = {}  # populated below before each function that returns an int

def check_errwarn(statcodes, func_name):
    if numpy.any(statcodes<0):
        # errors present - only report the errors.

        errcodes = numpy.unique(statcodes[statcodes<0])

        errcounts = dict([(e, numpy.sum(statcodes==e)) for e in errcodes])

        elsemsg = STATUS_CODES[func_name].get('else', None)
        if elsemsg is None:
            errmsgs = dict([(e, STATUS_CODES[func_name].get(e, 'Return code ' + str(e))) for e in errcodes])
        else:
            errmsgs = dict([(e, STATUS_CODES[func_name].get(e, elsemsg)) for e in errcodes])

        emsg = ', '.join(['{0} of "{1}"'.format(errcounts[e], errmsgs[e]) for e in errcodes])
        raise ErfaError('ERFA function "' + func_name + '" yielded ' + emsg)

    elif numpy.any(statcodes>0):
        #only warnings present
        warncodes = numpy.unique(statcodes[statcodes>0])

        warncounts = dict([(w, numpy.sum(statcodes==w)) for w in warncodes])

        elsemsg = STATUS_CODES[func_name].get('else', None)
        if elsemsg is None:
            warnmsgs = dict([(w, STATUS_CODES[func_name].get(w, 'Return code ' + str(w))) for w in warncodes])
        else:
            warnmsgs = dict([(w, STATUS_CODES[func_name].get(w, elsemsg)) for w in warncodes])

        wmsg = ', '.join(['{0} of "{1}"'.format(warncounts[w], warnmsgs[w]) for w in warncodes])
        warnings.warn('ERFA function "' + func_name + '" yielded ' + wmsg, ErfaWarning)


#<--------------------------Actual ERFA-wrapping code------------------------->

cdef extern from "erfa.h":
    struct eraASTROM:
        pass
    struct eraLDBODY:
        pass
{%- for func in funcs %}
    {{ func.ret }} {{ func.name }}({{ func.args_by_inout('in|inout|out')|map(attribute='ctype_ptr')|join(', ') }})
{%- endfor %}

dt_eraASTROM = numpy.dtype([('pmt','d'),
                         ('eb','d',(3,)),
                         ('eh','d',(3,)),
                         ('em','d'),
                         ('v','d',(3,)),
                         ('bm1 ','d'),
                         ('bpn','d',(3,3)),
                         ('along','d'),
                         ('phi','d'),
                         ('xpl','d'),
                         ('ypl','d'),
                         ('sphi','d'),
                         ('cphi','d'),
                         ('diurab','d'),
                         ('eral','d'),
                         ('refa','d'),
                         ('refb','d')], align=True)

dt_eraLDBODY = numpy.dtype([('bm','d'),
                         ('dl','d'),
                         ('pv','d',(2,3))], align=True)



{% for func in funcs %}
def {{ func.pyname }}({{ func.args_by_inout('in|inout')|map(attribute='name')|join(', ') }}):
    """
    {{ func.pyname }}({{ func.args_by_inout('in|inout')|map(attribute='name')|join(', ') }})

    Returns: {{ func.args_by_inout('inout|out|ret')|map(attribute='name')|postfix('_out')|join(', ') }}

    ERFA documentation:
    {{ func.doc }}
    """
    {%- for arg in func.args_by_inout('in') %}
    {%- if arg.ndims > 0 %}
    # convert nd-array to single-field structured array for argument "{{ arg.name }}"
    {{ arg.name }}_arr = numpy.empty(numpy.shape({{ arg.name }})[:-{{ arg.ndims }}], dtype={{ arg.dtype }})
    {{ arg.name }}_arr['fi0'] = {{ arg.name }}
    {{ arg.name }} = {{ arg.name }}_arr
    {% endif %}
    {%- endfor %}
    
    {%- if func.args_by_inout('in|inout') %}
    {%- if func.args_by_inout('in|inout')|map(attribute='name')|list|length < 2 %}
    in_shape = numpy.broadcast({{ func.args_by_inout('in|inout')|map(attribute='name')|first }}, 0).shape
    {%- else %}
    in_shape = numpy.broadcast({{ func.args_by_inout('in|inout')|map(attribute='name')|join(', ') }}).shape
    {%- endif %}
    {%- for arg in func.args_by_inout('out|ret|stat') %}
    {{ arg.name }}_out = numpy.empty(in_shape, dtype={{ arg.dtype }})
    {%- endfor %}
    {%- for arg in func.args_by_inout('inout') %}
    {{ arg.name }}_out = numpy.array(numpy.broadcast_arrays({{ func.args_by_inout('in|inout')|map(attribute='name')|join(', ') }})[{{ func.args.index(arg) }}], dtype={{ arg.dtype }})
    {%- endfor %}
    
    cdef numpy.broadcast it = numpy.broadcast({{ (func.args_by_inout('in')|map(attribute='name')|list + func.args_by_inout('inout|out|ret|stat')|map(attribute='name')|postfix('_out')|list) |join(', ') }})
    {%- for arg in func.args_by_inout('in|inout|out|ret|stat') %}
    cdef {{ arg.ctype_ptr }} _{{ arg.name }}
    {%- endfor %}
    {%- if func.args_by_inout('stat')|length > 0 %}
    cdef bint stat_ok = True
    {%- endif %}
    
    while numpy.PyArray_MultiIter_NOTDONE(it):
        
        {%- for arg in func.args_by_inout('in|inout|out') %}
        {%- if arg.ctype_ptr[-1] == '*' %}
        _{{ arg.name }} = (<{{ arg.ctype_ptr }}>numpy.PyArray_MultiIter_DATA(it, {{ func.args.index(arg) }}))
        {%- else %}
        _{{ arg.name }} = (<{{ arg.ctype_ptr }}*>numpy.PyArray_MultiIter_DATA(it, {{ func.args.index(arg) }}))[0]
        {%- endif %}
        {%- endfor %}
        
        {{ func.args_by_inout('ret|stat')|map(attribute='name')|surround('_',' = ')|join }}{{ func.name }}({{ func.args_by_inout('in|out|inout')|map(attribute='name')|prefix('_')|join(', ') }})
        
        {%- for arg in func.args_by_inout('ret|stat') %}
        (<{{ arg.ctype_ptr }}*>numpy.PyArray_MultiIter_DATA(it, {{ func.args.index(arg) }}))[0] = _{{ arg.name }}
        {%- if arg.inout_state == 'stat' %}
        if _{{ arg.name }} != 0:
            stat_ok = False
        {%- endif %}
        {%- endfor %}
        
        numpy.PyArray_MultiIter_NEXT(it)
    {%- else %}
    in_shape = ()
    {%- for arg in func.args_by_inout('out') %}
    {{ arg.name }}_out = numpy.empty(in_shape, dtype={{ arg.dtype }})
    {%- endfor %}
    
    cdef numpy.broadcast it = numpy.broadcast({{ (func.args_by_inout('in')|map(attribute='name')|list + func.args_by_inout('inout|out|ret')|map(attribute='name')|postfix('_out')|list) |join(', ') }})
    {%- for arg in func.args_by_inout('out') %}
    cdef {{ arg.ctype_ptr }} _{{ arg.name }}
    {%- endfor %}
    
    while numpy.PyArray_MultiIter_NOTDONE(it):
        
        {%- for arg in func.args_by_inout('in|inout|out') %}
        {%- if arg.ctype_ptr[-1] == '*' %}
        _{{ arg.name }} = (<{{ arg.ctype_ptr }}>numpy.PyArray_MultiIter_DATA(it, {{ func.args.index(arg) }}))
        {%- else %}
        _{{ arg.name }} = (<{{ arg.ctype_ptr }}*>numpy.PyArray_MultiIter_DATA(it, {{ func.args.index(arg) }}))[0]
        {%- endif %}
        {%- endfor %}
    
        {{ func.name }}({{ func.args_by_inout('in|out|inout')|map(attribute='name')|prefix('_')|join(', ') }})
        
        numpy.PyArray_MultiIter_NEXT(it)
    {%- endif %}
    
    {%- for stat in func.args_by_inout('stat') %}

    if not stat_ok:
        check_errwarn({{ stat.name }}_out, '{{ func.pyname }}')
    {%- endfor %}

    {%- set nd_comment_done = False %}
    {%- for arg in func.args_by_inout('out') %}
    {%- if arg.ndims > 0 %}
    {%- if not nd_comment_done%} 

    # convert from single-field structured dtype to regular nd-array
    {%- set nd_comment_done = True %}
    {%- endif %}
    {{ arg.name }}_out = {{ arg.name }}_out['fi0']
    {%- endif %}
    {%- endfor %}

    return {{ func.args_by_inout('out|ret')|map(attribute='name')|postfix('_out')|join(', ') }}

{%- for stat in func.args_by_inout('stat') %}
{%- if stat.doc_info.statuscodes %}
STATUS_CODES['{{ func.pyname }}'] = {{ stat.doc_info.statuscodes|string }}
{% endif %}
{%- endfor %}
{% endfor %}
