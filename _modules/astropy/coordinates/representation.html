<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>astropy.coordinates.representation &#8212; Astropy v3.0.dev19489</title>
    
    <link rel="stylesheet" href="../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '3.0.dev19489',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/astropy_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>
<script type="text/javascript" src="../../../_static/copybutton.js"></script>


  </head>
  <body role="document">
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">Astropy v3.0.dev19489</a>
	 &#187;
      </li>
      <li><a href="../../index.html" >Module code</a> &#187;</li>
      <li><a href="../../astropy.html" accesskey="U">astropy</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for astropy.coordinates.representation</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">In this module, we define the coordinate representation classes, which are</span>
<span class="sd">used to represent low-level cartesian, spherical, cylindrical, and other</span>
<span class="sd">coordinates.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">astropy.units</span> <span class="k">as</span> <span class="nn">u</span>

<span class="kn">from</span> <span class="nn">.angles</span> <span class="k">import</span> <span class="n">Angle</span><span class="p">,</span> <span class="n">Longitude</span><span class="p">,</span> <span class="n">Latitude</span>
<span class="kn">from</span> <span class="nn">.distances</span> <span class="k">import</span> <span class="n">Distance</span>
<span class="kn">from</span> <span class="nn">..extern</span> <span class="k">import</span> <span class="n">six</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="k">import</span> <span class="n">ShapedLikeNDArray</span><span class="p">,</span> <span class="n">classproperty</span>
<span class="kn">from</span> <span class="nn">..utils.misc</span> <span class="k">import</span> <span class="n">InheritDocstrings</span>
<span class="kn">from</span> <span class="nn">..utils.compat</span> <span class="k">import</span> <span class="n">NUMPY_LT_1_12</span>
<span class="kn">from</span> <span class="nn">..utils.compat.numpy</span> <span class="k">import</span> <span class="n">broadcast_arrays</span><span class="p">,</span> <span class="n">broadcast_to</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;BaseRepresentationOrDifferential&quot;</span><span class="p">,</span> <span class="s2">&quot;BaseRepresentation&quot;</span><span class="p">,</span>
           <span class="s2">&quot;CartesianRepresentation&quot;</span><span class="p">,</span> <span class="s2">&quot;SphericalRepresentation&quot;</span><span class="p">,</span>
           <span class="s2">&quot;UnitSphericalRepresentation&quot;</span><span class="p">,</span> <span class="s2">&quot;RadialRepresentation&quot;</span><span class="p">,</span>
           <span class="s2">&quot;PhysicsSphericalRepresentation&quot;</span><span class="p">,</span> <span class="s2">&quot;CylindricalRepresentation&quot;</span><span class="p">,</span>
           <span class="s2">&quot;BaseDifferential&quot;</span><span class="p">,</span> <span class="s2">&quot;CartesianDifferential&quot;</span><span class="p">,</span>
           <span class="s2">&quot;BaseSphericalDifferential&quot;</span><span class="p">,</span> <span class="s2">&quot;BaseSphericalCosLatDifferential&quot;</span><span class="p">,</span>
           <span class="s2">&quot;SphericalDifferential&quot;</span><span class="p">,</span> <span class="s2">&quot;SphericalCosLatDifferential&quot;</span><span class="p">,</span>
           <span class="s2">&quot;UnitSphericalDifferential&quot;</span><span class="p">,</span> <span class="s2">&quot;UnitSphericalCosLatDifferential&quot;</span><span class="p">,</span>
           <span class="s2">&quot;RadialDifferential&quot;</span><span class="p">,</span> <span class="s2">&quot;CylindricalDifferential&quot;</span><span class="p">,</span>
           <span class="s2">&quot;PhysicsSphericalDifferential&quot;</span><span class="p">]</span>

<span class="c1"># Module-level dict mapping representation string alias names to classes.</span>
<span class="c1"># This is populated by the metaclass init so all representation and differential</span>
<span class="c1"># classes get registered automatically.</span>
<span class="n">REPRESENTATION_CLASSES</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">DIFFERENTIAL_CLASSES</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">def</span> <span class="nf">_array2string</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="c1"># Mimic numpy &gt;=1.12 array2string, in which structured arrays are</span>
    <span class="c1"># typeset taking into account all printoptions.</span>
    <span class="k">if</span> <span class="n">NUMPY_LT_1_12</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="c1"># Mimic StructureFormat from numpy &gt;=1.12 assuming float-only data.</span>
        <span class="kn">from</span> <span class="nn">numpy.core.arrayprint</span> <span class="k">import</span> <span class="n">FloatFormat</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()</span>
        <span class="n">format_functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">FloatFormat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">component</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                        <span class="n">precision</span><span class="o">=</span><span class="n">opts</span><span class="p">[</span><span class="s1">&#39;precision&#39;</span><span class="p">],</span>
                                        <span class="n">suppress_small</span><span class="o">=</span><span class="n">opts</span><span class="p">[</span><span class="s1">&#39;suppress&#39;</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">fmt</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">format_function</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
                                           <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">format_function</span> <span class="ow">in</span>
                                           <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">format_functions</span><span class="p">)))</span>
        <span class="c1"># Before 1.12, structures arrays were set as &quot;numpystr&quot;,</span>
        <span class="c1"># so that is the formmater we need to replace.</span>
        <span class="n">formatter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;numpystr&#39;</span><span class="p">:</span> <span class="n">fmt</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="nb">repr</span>
        <span class="n">formatter</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="n">formatter</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span>
                           <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_combine_xyz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine components ``x``, ``y``, ``z`` into a single Quantity array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y, z : `~astropy.units.Quantity`</span>
<span class="sd">        The individual x, y, and z components.</span>
<span class="sd">    xyz_axis : int, optional</span>
<span class="sd">        The axis in the final array along which the x, y, z components</span>
<span class="sd">        should be stored (default: 0).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xyz : `~astropy.units.Quantity`</span>
<span class="sd">        With dimension 3 along ``xyz_axis``, i.e., using the default of ``0``,</span>
<span class="sd">        the shape will be ``(3,) + x.shape``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Add new axis in x, y, z so one can concatenate them around it.</span>
    <span class="c1"># NOTE: just use np.stack once our minimum numpy version is 1.10.</span>
    <span class="n">result_ndim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="o">-</span><span class="n">result_ndim</span> <span class="o">&lt;=</span> <span class="n">xyz_axis</span> <span class="o">&lt;</span> <span class="n">result_ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;xyz_axis </span><span class="si">{0}</span><span class="s1"> out of bounds [-</span><span class="si">{1}</span><span class="s1">, </span><span class="si">{1}</span><span class="s1">)&#39;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xyz_axis</span><span class="p">,</span> <span class="n">result_ndim</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">xyz_axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">xyz_axis</span> <span class="o">+=</span> <span class="n">result_ndim</span>

    <span class="c1"># Get x, y, z to the same units (this is very fast for identical units)</span>
    <span class="c1"># since np.concatenate cannot deal with quantity.</span>
    <span class="n">cls</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">__class__</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">sh</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="n">sh</span><span class="p">[:</span><span class="n">xyz_axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">sh</span><span class="p">[</span><span class="n">xyz_axis</span><span class="p">:]</span>
    <span class="n">xyz_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)],</span>
                               <span class="n">axis</span><span class="o">=</span><span class="n">xyz_axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">xyz_value</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<div class="viewcode-block" id="BaseRepresentationOrDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentationOrDifferential.html#astropy.coordinates.BaseRepresentationOrDifferential">[docs]</a><span class="k">class</span> <span class="nc">BaseRepresentationOrDifferential</span><span class="p">(</span><span class="n">ShapedLikeNDArray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;3D coordinate representations and differentials.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    comp1, comp2, comp3 : `~astropy.units.Quantity` or subclass</span>
<span class="sd">        The components of the 3D point or differential.  The names are the</span>
<span class="sd">        keys and the subclasses the values of the ``attr_classes`` attribute.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ensure multiplication/division with ndarray or Quantity doesn&#39;t lead to</span>
    <span class="c1"># object arrays.</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">50000</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># make argument a list, so we can pop them off.</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">args</span> <span class="k">else</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">component</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;__init__() missing 1 required positional &#39;</span>
                                <span class="s1">&#39;argument: </span><span class="si">{0!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component</span><span class="p">))</span>

        <span class="n">copy</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">args</span> <span class="k">else</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unexpected arguments: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;__init__() got multiple values for &quot;</span>
                                    <span class="s2">&quot;argument </span><span class="si">{0!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component</span><span class="p">))</span>

            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unexpected keyword arguments: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="c1"># Pass attributes through the required initializing classes.</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">attr_classes</span><span class="p">[</span><span class="n">component</span><span class="p">](</span><span class="n">attr</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">attrs</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">c_str</span> <span class="o">=</span> <span class="s1">&#39; and &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">components</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;, and &#39;</span> <span class="o">+</span> <span class="n">components</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input parameters </span><span class="si">{0}</span><span class="s2"> cannot be broadcast&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c_str</span><span class="p">))</span>
        <span class="c1"># Set private attributes for the attributes. (If not defined explicitly</span>
        <span class="c1"># on the class, the metaclass will define properties to access these.)</span>
        <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">component</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="BaseRepresentationOrDifferential.get_name"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentationOrDifferential.html#astropy.coordinates.BaseRepresentationOrDifferential.get_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Name of the representation or differential.</span>

<span class="sd">        In lower case, with any trailing &#39;representation&#39; or &#39;differential&#39;</span>
<span class="sd">        removed. (E.g., &#39;spherical&#39; for</span>
<span class="sd">        `~astropy.coordinates.SphericalRepresentation` or</span>
<span class="sd">        `~astropy.coordinates.SphericalDifferential`.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;representation&#39;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">14</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;differential&#39;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">name</span></div>

    <span class="c1"># The two methods that any subclass has to define.</span>
    <span class="c1"># Should be replaced by abstractclassmethod once we support only PY3</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
<div class="viewcode-block" id="BaseRepresentationOrDifferential.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentationOrDifferential.html#astropy.coordinates.BaseRepresentationOrDifferential.from_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a representation of this class from a supplied Cartesian one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `CartesianRepresentation`</span>
<span class="sd">            The representation to turn into this class</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        representation : object of this class</span>
<span class="sd">            A new representation of this class&#39;s type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: the above docstring gets overridden for differentials.</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
<div class="viewcode-block" id="BaseRepresentationOrDifferential.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentationOrDifferential.html#astropy.coordinates.BaseRepresentationOrDifferential.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the representation to its Cartesian form.</span>

<span class="sd">        Note that any differentials get dropped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cartrepr : `CartesianRepresentation`</span>
<span class="sd">            The representation in Cartesian form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: the above docstring gets overridden for differentials.</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A tuple with the in-order names of the coordinate components.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr_classes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new representation or differential with ``method`` applied</span>
<span class="sd">        to the component data.</span>

<span class="sd">        In typical usage, the method is any of the shape-changing methods for</span>
<span class="sd">        `~numpy.ndarray` (``reshape``, ``swapaxes``, etc.), as well as those</span>
<span class="sd">        picking particular elements (``__getitem__``, ``take``, etc.), which</span>
<span class="sd">        are all defined in `~astropy.utils.misc.ShapedLikeNDArray`. It will be</span>
<span class="sd">        applied to the underlying arrays (e.g., ``x``, ``y``, and ``z`` for</span>
<span class="sd">        `~astropy.coordinates.CartesianRepresentation`), with the results used</span>
<span class="sd">        to create a new instance.</span>

<span class="sd">        Internally, it is also used to apply functions to the components</span>
<span class="sd">        (in particular, `~numpy.broadcast_to`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str or callable</span>
<span class="sd">            If str, it is the name of a method that is applied to the internal</span>
<span class="sd">            ``components``. If callable, the function is applied.</span>
<span class="sd">        args : tuple</span>
<span class="sd">            Any positional arguments for ``method``.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Any keyword arguments for ``method``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
            <span class="n">apply_method</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">method</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">apply_method</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">methodcaller</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">apply_method</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">))</span>
                                <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The shape of the instance and underlying arrays.</span>

<span class="sd">        Like `~numpy.ndarray.shape`, can be set to a new shape by assigning a</span>
<span class="sd">        tuple.  Note that if different instances share some but not all</span>
<span class="sd">        underlying data, setting the shape of one instance can make the other</span>
<span class="sd">        instance unusable.  Hence, it is strongly recommended to get new,</span>
<span class="sd">        reshaped instances with the ``reshape`` method.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If the shape of any of the components cannot be changed without the</span>
<span class="sd">            arrays being copied.  For these cases, use the ``reshape`` method</span>
<span class="sd">            (which copies any arrays that cannot be reshaped in-place).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@shape</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="c1"># We keep track of arrays that were already reshaped since we may have</span>
        <span class="c1"># to return those to their original shape if a later shape-setting</span>
        <span class="c1"># fails. (This can happen since coordinates are broadcast together.)</span>
        <span class="n">reshaped</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">oldshape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">val2</span> <span class="ow">in</span> <span class="n">reshaped</span><span class="p">:</span>
                        <span class="n">val2</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">oldshape</span>
                    <span class="k">raise</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">reshaped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="c1"># Required to support multiplication and division, and defined by the base</span>
    <span class="c1"># representation and differential classes.</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>  <span class="c1"># pragma: py2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">)</span>

    <span class="c1"># Follow numpy convention and make an independent copy.</span>
    <span class="k">def</span> <span class="nf">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Required to support addition and subtraction, and defined by the base</span>
    <span class="c1"># representation and differential classes.</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># The following are used for repr and str</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn the coordinates into a record array with the coordinate values.</span>

<span class="sd">        The record array fields will have the component names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The &quot;str(c)&quot; is needed for PY2; it can be removed for astropy 3.0.</span>
        <span class="n">coo_items</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">[(</span><span class="n">c</span><span class="p">,</span> <span class="n">coo</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">coo</span> <span class="ow">in</span> <span class="n">coo_items</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">coo</span> <span class="ow">in</span> <span class="n">coo_items</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">coo</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary with the units of the coordinate components.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">component</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_unitstr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">units_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_units</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">units_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">unitstr</span> <span class="o">=</span> <span class="n">units_set</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unitstr</span> <span class="o">=</span> <span class="s1">&#39;(</span><span class="si">{0}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_units</span><span class="p">[</span><span class="n">component</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>
                           <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">unitstr</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1:s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_array2string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prefixstr</span> <span class="o">=</span> <span class="s1">&#39;    &#39;</span>
        <span class="n">arrstr</span> <span class="o">=</span> <span class="n">_array2string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefixstr</span><span class="p">)</span>

        <span class="n">diffstr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;differentials&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">diffstr</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> (has differentials w.r.t.: </span><span class="si">{0}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">keys</span><span class="p">()]))</span>

        <span class="n">unitstr</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;in &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span> <span class="k">else</span> <span class="s1">&#39;[dimensionless]&#39;</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{0}</span><span class="s1"> (</span><span class="si">{1}</span><span class="s1">) </span><span class="si">{2:s}</span><span class="se">\n</span><span class="si">{3}{4}{5}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">),</span>
            <span class="n">unitstr</span><span class="p">,</span> <span class="n">prefixstr</span><span class="p">,</span> <span class="n">arrstr</span><span class="p">,</span> <span class="n">diffstr</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_make_getter</span><span class="p">(</span><span class="n">component</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make an attribute getter for use in a property.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    component : str</span>
<span class="sd">        The name of the component that should be accessed.  This assumes the</span>
<span class="sd">        actual value is stored in an attribute of that name prefixed by &#39;_&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This has to be done in a function to ensure the reference to component</span>
    <span class="c1"># is not lost/redirected.</span>
    <span class="n">component</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">component</span>

    <span class="k">def</span> <span class="nf">get_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">get_component</span>


<span class="c1"># Need to also subclass ABCMeta rather than type, so that this meta class can</span>
<span class="c1"># be combined with a ShapedLikeNDArray subclass (which is an ABC).  Without it:</span>
<span class="c1"># &quot;TypeError: metaclass conflict: the metaclass of a derived class must be a</span>
<span class="c1">#  (non-strict) subclass of the metaclasses of all its bases&quot;</span>
<span class="k">class</span> <span class="nc">MetaBaseRepresentation</span><span class="p">(</span><span class="n">InheritDocstrings</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MetaBaseRepresentation</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span>

        <span class="c1"># Register representation name (except for BaseRepresentation)</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;BaseRepresentation&#39;</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="s1">&#39;attr_classes&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dct</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Representations must have an &#39;</span>
                                      <span class="s1">&#39;&quot;attr_classes&quot; class attribute.&#39;</span><span class="p">)</span>

        <span class="n">repr_name</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">repr_name</span> <span class="ow">in</span> <span class="n">REPRESENTATION_CLASSES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Representation class </span><span class="si">{0}</span><span class="s2"> already defined&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">repr_name</span><span class="p">))</span>

        <span class="n">REPRESENTATION_CLASSES</span><span class="p">[</span><span class="n">repr_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls</span>

        <span class="c1"># define getters for any component that does not yet have one.</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">attr_classes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span>
                        <span class="nb">property</span><span class="p">(</span><span class="n">_make_getter</span><span class="p">(</span><span class="n">component</span><span class="p">),</span>
                                 <span class="n">doc</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;The &#39;</span><span class="si">{0}</span><span class="s2">&#39; component of the points(s).&quot;</span>
                                      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component</span><span class="p">))))</span>


<span class="nd">@six</span><span class="o">.</span><span class="n">add_metaclass</span><span class="p">(</span><span class="n">MetaBaseRepresentation</span><span class="p">)</span>
<div class="viewcode-block" id="BaseRepresentation"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation">[docs]</a><span class="k">class</span> <span class="nc">BaseRepresentation</span><span class="p">(</span><span class="n">BaseRepresentationOrDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base for representing a point in a 3D coordinate system.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    comp1, comp2, comp3 : `~astropy.units.Quantity` or subclass</span>
<span class="sd">        The components of the 3D points.  The names are the keys and the</span>
<span class="sd">        subclasses the values of the ``attr_classes`` attribute.</span>
<span class="sd">    differentials : dict, `BaseDifferential`, optional</span>
<span class="sd">        Any differential classes that should be associated with this</span>
<span class="sd">        representation. The input must either be a single `BaseDifferential`</span>
<span class="sd">        subclass instance, or a dictionary with keys set to a string</span>
<span class="sd">        representation of the SI unit with which the differential (derivative)</span>
<span class="sd">        is taken. For example, for a velocity differential on a positional</span>
<span class="sd">        representation, the key would be ``&#39;s&#39;`` for seconds, indicating that</span>
<span class="sd">        the derivative is a time derivative.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    All representation classes should subclass this base representation class,</span>
<span class="sd">    and define an ``attr_classes`` attribute, an `~collections.OrderedDict`</span>
<span class="sd">    which maps component names to the class that creates them. They must also</span>
<span class="sd">    define a ``to_cartesian`` method and a ``from_cartesian`` class method. By</span>
<span class="sd">    default, transformations are done via the cartesian system, but classes</span>
<span class="sd">    that want to define a smarter transformation path can overload the</span>
<span class="sd">    ``represent_as`` method. If one wants to use an associated differential</span>
<span class="sd">    class, one should also define ``unit_vectors`` and ``scale_factors``</span>
<span class="sd">    methods (see those methods for details). Finally, classes can also define a</span>
<span class="sd">    ``recommended_units`` dictionary, which maps component names to the units</span>
<span class="sd">    they are best presented to users in (this is used only in representations</span>
<span class="sd">    of coordinates, and may be overridden by frame classes).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">recommended_units</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># subclasses can override</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Handle any differentials passed in.</span>
        <span class="n">differentials</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;differentials&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BaseRepresentation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_differentials</span><span class="p">(</span><span class="n">differentials</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">differentials</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate that the provided differentials are appropriate for this</span>
<span class="sd">        representation and recast/reshape as necessary and then return.</span>

<span class="sd">        Note that this does *not* set the differentials on</span>
<span class="sd">        ``self._differentials``, but rather leaves that for the caller.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Now handle the actual validation of any specified differential classes</span>
        <span class="k">if</span> <span class="n">differentials</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">differentials</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">differentials</span><span class="p">,</span> <span class="n">BaseDifferential</span><span class="p">):</span>
            <span class="c1"># We can&#39;t handle auto-determining the key for this combo</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">differentials</span><span class="p">,</span> <span class="n">RadialDifferential</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">UnitSphericalRepresentation</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;To attach a RadialDifferential to a &quot;</span>
                                 <span class="s2">&quot;UnitSphericalRepresentation, you must supply &quot;</span>
                                 <span class="s2">&quot;a dictionary with an appropriate key.&quot;</span><span class="p">)</span>

            <span class="n">key</span> <span class="o">=</span> <span class="n">differentials</span><span class="o">.</span><span class="n">_get_deriv_key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">differentials</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">differentials</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">differentials</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">differentials</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;differentials&#39; argument must be a &quot;</span>
                                <span class="s2">&quot;dictionary-like object&quot;</span><span class="p">)</span>

            <span class="n">diff</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">RadialDifferential</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">UnitSphericalRepresentation</span><span class="p">)):</span>
                <span class="c1"># We trust the passing of a key for a RadialDifferential</span>
                <span class="c1"># attached to a UnitSphericalRepresentation because it will not</span>
                <span class="c1"># have a paired component name (UnitSphericalRepresentation has</span>
                <span class="c1"># no .distance) to automatically determine the expected key</span>
                <span class="k">pass</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">expected_key</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">_get_deriv_key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">expected_key</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For differential object &#39;</span><span class="si">{0}</span><span class="s2">&#39;, expected &quot;</span>
                                     <span class="s2">&quot;unit key = &#39;</span><span class="si">{1}</span><span class="s2">&#39; but received key = &#39;</span><span class="si">{2}</span><span class="s2">&#39;&quot;</span>
                                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">diff</span><span class="p">),</span> <span class="n">expected_key</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>

            <span class="c1"># For now, we are very rigid: differentials must have the same shape</span>
            <span class="c1"># as the representation. This makes it easier to handle __getitem__</span>
            <span class="c1"># and any other shape-changing operations on representations that</span>
            <span class="c1"># have associated differentials</span>
            <span class="k">if</span> <span class="n">diff</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="c1"># TODO: message of IncompatibleShapeError is not customizable,</span>
                <span class="c1">#       so use a valueerror instead?</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape of differentials must be the same &quot;</span>
                                 <span class="s2">&quot;as the shape of the representation (</span><span class="si">{0}</span><span class="s2"> vs &quot;</span>
                                 <span class="s2">&quot;</span><span class="si">{1}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">differentials</span>

    <span class="k">def</span> <span class="nf">_raise_if_has_differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to raise a consistent exception for any operation that is not</span>
<span class="sd">        supported when a representation has differentials attached.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Operation &#39;</span><span class="si">{0}</span><span class="s2">&#39; is not supported when &quot;</span>
                            <span class="s2">&quot;differentials are attached to a </span><span class="si">{1}</span><span class="s2">.&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_compatible_differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">DIFFERENTIAL_CLASSES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">()]]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A dictionary of differential class instances.</span>

<span class="sd">        The keys of this dictionary must be a string representation of the SI</span>
<span class="sd">        unit with which the differential (derivative) is taken. For example, for</span>
<span class="sd">        a velocity differential on a positional representation, the key would be</span>
<span class="sd">        ``&#39;s&#39;`` for seconds, indicating that the derivative is a time</span>
<span class="sd">        derivative.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span>

    <span class="c1"># We do not make unit_vectors and scale_factors abstract methods, since</span>
    <span class="c1"># they are only necessary if one also defines an associated Differential.</span>
    <span class="c1"># Also, doing so would break pre-differential representation subclasses.</span>
<div class="viewcode-block" id="BaseRepresentation.unit_vectors"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.unit_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">unit_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Cartesian unit vectors in the direction of each component.</span>

<span class="sd">        Given unit vectors :math:`\hat{e}_c` and scale factors :math:`f_c`,</span>
<span class="sd">        a change in one component of :math:`\delta c` corresponds to a change</span>
<span class="sd">        in representation of :math:`\delta c \times f_c \times \hat{e}_c`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unit_vectors : dict of `CartesianRepresentation`</span>
<span class="sd">            The keys are the component names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> has not implemented unit vectors&quot;</span>
                                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span></div>

<div class="viewcode-block" id="BaseRepresentation.scale_factors"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Scale factors for each component&#39;s direction.</span>

<span class="sd">        Given unit vectors :math:`\hat{e}_c` and scale factors :math:`f_c`,</span>
<span class="sd">        a change in one component of :math:`\delta c` corresponds to a change</span>
<span class="sd">        in representation of :math:`\delta c \times f_c \times \hat{e}_c`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scale_factors : dict of `~astropy.units.Quantity`</span>
<span class="sd">            The keys are the component names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> has not implemented scale factors.&quot;</span>
                                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span></div>

    <span class="k">def</span> <span class="nf">_re_represent_differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_rep</span><span class="p">,</span> <span class="n">differential_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Re-represent the differentials to the specified classes.</span>

<span class="sd">        This returns a new dictionary with the same keys but with the</span>
<span class="sd">        attached differentials converted to the new differential classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">differential_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span> <span class="ow">and</span> <span class="n">differential_class</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No differentials associated with this &quot;</span>
                             <span class="s2">&quot;representation!&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">differential_class</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">issubclass</span><span class="p">(</span><span class="n">differential_class</span><span class="p">,</span> <span class="n">BaseDifferential</span><span class="p">)):</span>
            <span class="c1"># TODO: is there a better way to do this?</span>
            <span class="n">differential_class</span> <span class="o">=</span> <span class="p">{</span>
                <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">differential_class</span>
            <span class="p">}</span>

        <span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">differential_class</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Desired differential classes must be passed in &quot;</span>
                       <span class="s2">&quot;as a dictionary with keys equal to a string &quot;</span>
                       <span class="s2">&quot;representation of the unit of the derivative &quot;</span>
                       <span class="s2">&quot;for each differential stored with this &quot;</span>
                       <span class="s2">&quot;representation object (</span><span class="si">{0}</span><span class="s2">)&quot;</span>
                       <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">))</span>

        <span class="n">new_diffs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_diffs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">differential_class</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                                 <span class="n">base</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">differential_class</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span>
                        <span class="n">new_rep</span><span class="o">.</span><span class="n">_compatible_differentials</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Desired differential class </span><span class="si">{0}</span><span class="s2"> is not &quot;</span>
                                    <span class="s2">&quot;compatible with the desired &quot;</span>
                                    <span class="s2">&quot;representation class </span><span class="si">{1}</span><span class="s2">&quot;</span>
                                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">differential_class</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                            <span class="n">new_rep</span><span class="o">.</span><span class="n">__class__</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

        <span class="k">return</span> <span class="n">new_diffs</span>

<div class="viewcode-block" id="BaseRepresentation.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">differential_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert coordinates to another representation.</span>

<span class="sd">        If the instance is of the requested class, it is returned unmodified.</span>
<span class="sd">        By default, conversion is done via cartesian coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other_class : `~astropy.coordinates.BaseRepresentation` subclass</span>
<span class="sd">            The type of representation to turn the coordinates into.</span>
<span class="sd">        differential_class : dict of `~astropy.coordinates.BaseDifferential`, optional</span>
<span class="sd">            Classes in which the differentials should be represented.</span>
<span class="sd">            Can be a single class if only a single differential is attached,</span>
<span class="sd">            otherwise it should be a `dict` keyed by the same keys as the</span>
<span class="sd">            differentials.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other_class</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">differential_class</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">without_differentials</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input to a representation&#39;s represent_as &quot;</span>
                                 <span class="s2">&quot;must be a class, not a string. For &quot;</span>
                                 <span class="s2">&quot;strings, use frame objects&quot;</span><span class="p">)</span>

            <span class="c1"># The default is to convert via cartesian coordinates</span>
            <span class="n">new_rep</span> <span class="o">=</span> <span class="n">other_class</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">())</span>

            <span class="n">new_rep</span><span class="o">.</span><span class="n">_differentials</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_represent_differentials</span><span class="p">(</span>
                <span class="n">new_rep</span><span class="p">,</span> <span class="n">differential_class</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">new_rep</span></div>

<div class="viewcode-block" id="BaseRepresentation.with_differentials"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.with_differentials">[docs]</a>    <span class="k">def</span> <span class="nf">with_differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">differentials</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new representation with the same positions as this</span>
<span class="sd">        representation, but with these new differentials.</span>

<span class="sd">        Differential keys that already exist in this object&#39;s differential dict</span>
<span class="sd">        are overwritten.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        differentials : Sequence of `~astropy.coordinates.BaseDifferential`</span>
<span class="sd">            The differentials for the new representation to have.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newrepr</span>
<span class="sd">            A copy of this representation, but with the ``differentials`` as</span>
<span class="sd">            its differentials.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">differentials</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">]</span>

        <span class="c1"># We shallow copy the differentials dictionary so we don&#39;t update the</span>
        <span class="c1"># current object&#39;s dictionary when adding new keys</span>
        <span class="n">new_rep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                 <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">new_rep</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">new_rep</span><span class="o">.</span><span class="n">_validate_differentials</span><span class="p">(</span><span class="n">differentials</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">new_rep</span></div>

<div class="viewcode-block" id="BaseRepresentation.without_differentials"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.without_differentials">[docs]</a>    <span class="k">def</span> <span class="nf">without_differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the representation without attached differentials.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newrepr</span>
<span class="sd">            A shallow copy of this representation, without any differentials.</span>
<span class="sd">            If no differentials were present, no copy is made.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="BaseRepresentation.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.from_representation">[docs]</a>    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new instance of this representation from another one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        representation : `~astropy.coordinates.BaseRepresentation` instance</span>
<span class="sd">            The presentation that should be converted to this class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">representation</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new representation with ``method`` applied to the component</span>
<span class="sd">        data.</span>

<span class="sd">        This is not a simple inherit from ``BaseRepresentationOrDifferential``</span>
<span class="sd">        because we need to call ``._apply()`` on any associated differential</span>
<span class="sd">        classes.</span>

<span class="sd">        See docstring for `BaseRepresentationOrDifferential._apply`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str or callable</span>
<span class="sd">            If str, it is the name of a method that is applied to the internal</span>
<span class="sd">            ``components``. If callable, the function is applied.</span>
<span class="sd">        args : tuple</span>
<span class="sd">            Any positional arguments for ``method``.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Any keyword arguments for ``method``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rep</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">BaseRepresentation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">rep</span><span class="o">.</span><span class="n">_differentials</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">diff</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
             <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">diff</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">return</span> <span class="n">rep</span>

    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scale all non-angular components, leaving angular ones unchanged.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op : `~operator` callable</span>
<span class="sd">            Operator to apply (e.g., `~operator.mul`, `~operator.neg`, etc.</span>
<span class="sd">        *args</span>
<span class="sd">            Any arguments required for the operator (typically, what is to</span>
<span class="sd">            be multiplied with, divided by).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_classes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">Angle</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>

        <span class="c1"># try/except catches anything that cannot initialize the class, such</span>
        <span class="c1"># as operations that returned NotImplemented or a representation</span>
        <span class="c1"># instead of a quantity (as would happen for, e.g., rep * rep).</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine two representation.</span>

<span class="sd">        By default, operate on the cartesian representations of both.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op : `~operator` callable</span>
<span class="sd">            Operator to apply (e.g., `~operator.add`, `~operator.sub`, etc.</span>
<span class="sd">        other : `~astropy.coordinates.BaseRepresentation` instance</span>
<span class="sd">            The other representation.</span>
<span class="sd">        reverse : bool</span>
<span class="sd">            Whether the operands should be reversed (e.g., as we got here via</span>
<span class="sd">            ``self.__rsub__`` because ``self`` is a subclass of ``other``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="c1"># We need to override this setter to support differentials</span>
    <span class="nd">@BaseRepresentationOrDifferential</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="n">orig_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># See: https://stackoverflow.com/questions/3336767/ for an example</span>
        <span class="n">BaseRepresentationOrDifferential</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

        <span class="c1"># also try to perform shape-setting on any associated differentials</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">BaseRepresentationOrDifferential</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orig_shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">orig_shape</span>

            <span class="k">raise</span>

<div class="viewcode-block" id="BaseRepresentation.norm"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector norm.</span>

<span class="sd">        The norm is the standard Frobenius norm, i.e., the square root of the</span>
<span class="sd">        sum of the squares of all components with non-angular units.</span>

<span class="sd">        Note that any associated differentials will be dropped during this</span>
<span class="sd">        operation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : `astropy.units.Quantity`</span>
<span class="sd">            Vector norm, with the same shape as the representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                           <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_classes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                           <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">Angle</span><span class="p">))))</span></div>

<div class="viewcode-block" id="BaseRepresentation.mean"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector mean.</span>

<span class="sd">        Averaging is done by converting the representation to cartesian, and</span>
<span class="sd">        taking the mean of the x, y, and z components. The result is converted</span>
<span class="sd">        back to the same representation as the input.</span>

<span class="sd">        Refer to `~numpy.mean` for full documentation of the arguments, noting</span>
<span class="sd">        that ``axis`` is the entry in the ``shape`` of the representation, and</span>
<span class="sd">        that the ``out`` argument cannot be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean : representation</span>
<span class="sd">            Vector mean, in the same representation as that of the input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="BaseRepresentation.sum"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector sum.</span>

<span class="sd">        Adding is done by converting the representation to cartesian, and</span>
<span class="sd">        summing the x, y, and z components. The result is converted back to the</span>
<span class="sd">        same representation as the input.</span>

<span class="sd">        Refer to `~numpy.sum` for full documentation of the arguments, noting</span>
<span class="sd">        that ``axis`` is the entry in the ``shape`` of the representation, and</span>
<span class="sd">        that the ``out`` argument cannot be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sum : representation</span>
<span class="sd">            Vector sum, in the same representation as that of the input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="BaseRepresentation.dot"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.dot">[docs]</a>    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dot product of two representations.</span>

<span class="sd">        The calculation is done by converting both ``self`` and ``other``</span>
<span class="sd">        to `~astropy.coordinates.CartesianRepresentation`.</span>

<span class="sd">        Note that any associated differentials will be dropped during this</span>
<span class="sd">        operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `~astropy.coordinates.BaseRepresentation`</span>
<span class="sd">            The representation to take the dot product with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dot_product : `~astropy.units.Quantity`</span>
<span class="sd">            The sum of the product of the x, y, and z components of the</span>
<span class="sd">            cartesian representations of ``self`` and ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseRepresentation.cross"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.cross">[docs]</a>    <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector cross product of two representations.</span>

<span class="sd">        The calculation is done by converting both ``self`` and ``other``</span>
<span class="sd">        to `~astropy.coordinates.CartesianRepresentation`, and converting the</span>
<span class="sd">        result back to the type of representation of ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : representation</span>
<span class="sd">            The representation to take the cross product with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cross_product : representation</span>
<span class="sd">            With vectors perpendicular to both ``self`` and ``other``, in the</span>
<span class="sd">            same type of representation as ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;cross&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">other</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="CartesianRepresentation"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation">[docs]</a><span class="k">class</span> <span class="nc">CartesianRepresentation</span><span class="p">(</span><span class="n">BaseRepresentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of points in 3D cartesian coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y, z : `~astropy.units.Quantity` or array</span>
<span class="sd">        The x, y, and z coordinates of the point(s). If ``x``, ``y``, and ``z``</span>
<span class="sd">        have different shapes, they should be broadcastable. If not quantity,</span>
<span class="sd">        ``unit`` should be set.  If only ``x`` is given, it is assumed that it</span>
<span class="sd">        contains an array with the 3 coordinates stored along ``xyz_axis``.</span>
<span class="sd">    unit : `~astropy.units.Unit` or str</span>
<span class="sd">        If given, the coordinates will be converted to this unit (or taken to</span>
<span class="sd">        be in this unit if not given.</span>
<span class="sd">    xyz_axis : int, optional</span>
<span class="sd">        The axis along which the coordinates are stored when a single array is</span>
<span class="sd">        provided rather than distinct ``x``, ``y``, and ``z`` (default: 0).</span>

<span class="sd">    differentials : dict, `CartesianDifferential`, optional</span>
<span class="sd">        Any differential classes that should be associated with this</span>
<span class="sd">        representation. The input must either be a single</span>
<span class="sd">        `CartesianDifferential` instance, or a dictionary of</span>
<span class="sd">        `CartesianDifferential` s with keys set to a string representation of</span>
<span class="sd">        the SI unit with which the differential (derivative) is taken. For</span>
<span class="sd">        example, for a velocity differential on a positional representation, the</span>
<span class="sd">        key would be ``&#39;s&#39;`` for seconds, indicating that the derivative is a</span>
<span class="sd">        time derivative.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attr_classes</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">),</span>
                                <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">),</span>
                                <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">differentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">xyz_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">xyz_axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">xyz_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;xyz_axis should only be set if x, y, and z are &quot;</span>
                             <span class="s2">&quot;in a single array passed in through x, &quot;</span>
                             <span class="s2">&quot;i.e., y and z should not be not given.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x, y, and z are required to instantiate </span><span class="si">{0}</span><span class="s2">&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">CartesianRepresentation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                                                      <span class="n">differentials</span><span class="o">=</span><span class="n">differentials</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">physical_type</span> <span class="o">==</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">physical_type</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">physical_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;x, y, and z should have matching physical types&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="CartesianRepresentation.unit_vectors"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.unit_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">unit_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="mf">0.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">((</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)),</span>
             <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)),</span>
             <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">))))</span></div>

<div class="viewcode-block" id="CartesianRepresentation.scale_factors"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(((</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">l</span><span class="p">)))</span></div>

<div class="viewcode-block" id="CartesianRepresentation.get_xyz"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.get_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">get_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a vector array of the x, y, and z coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz_axis : int, optional</span>
<span class="sd">            The axis in the final array along which the x, y, z components</span>
<span class="sd">            should be stored (default: 0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xyz : `~astropy.units.Quantity`</span>
<span class="sd">            With dimension 3 along ``xyz_axis``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_combine_xyz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=</span><span class="n">xyz_axis</span><span class="p">)</span></div>

    <span class="n">xyz</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_xyz</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="CartesianRepresentation.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.from_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span></div>

<div class="viewcode-block" id="CartesianRepresentation.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CartesianRepresentation.transform"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform the cartesian coordinates using a 3x3 matrix.</span>

<span class="sd">        This returns a new representation and does not modify the original one.</span>
<span class="sd">        Any differentials attached to this representation will also be</span>
<span class="sd">        transformed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : `~numpy.ndarray`</span>
<span class="sd">            A 3x3 transformation matrix, such as a rotation matrix.</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        We can start off by creating a cartesian representation object:</span>

<span class="sd">            &gt;&gt;&gt; from astropy import units as u</span>
<span class="sd">            &gt;&gt;&gt; from astropy.coordinates import CartesianRepresentation</span>
<span class="sd">            &gt;&gt;&gt; rep = CartesianRepresentation([1, 2] * u.pc,</span>
<span class="sd">            ...                               [2, 3] * u.pc,</span>
<span class="sd">            ...                               [3, 4] * u.pc)</span>

<span class="sd">        We now create a rotation matrix around the z axis:</span>

<span class="sd">            &gt;&gt;&gt; from astropy.coordinates.matrix_utilities import rotation_matrix</span>
<span class="sd">            &gt;&gt;&gt; rotation = rotation_matrix(30 * u.deg, axis=&#39;z&#39;)</span>

<span class="sd">        Finally, we can apply this transformation:</span>

<span class="sd">            &gt;&gt;&gt; rep_new = rep.transform(rotation)</span>
<span class="sd">            &gt;&gt;&gt; rep_new.xyz  # doctest: +FLOAT_CMP</span>
<span class="sd">            &lt;Quantity [[ 1.8660254 , 3.23205081],</span>
<span class="sd">                       [ 1.23205081, 1.59807621],</span>
<span class="sd">                       [ 3.        , 4.        ]] pc&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Avoid doing gratuitous np.array for things that look like arrays.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">matrix_shape</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
            <span class="n">matrix_shape</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">matrix_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tried to do matrix multiplication with an array &quot;</span>
                             <span class="s2">&quot;that doesn&#39;t end in 3x3&quot;</span><span class="p">)</span>

        <span class="c1"># TODO: since this is likely to be a widely used function in coordinate</span>
        <span class="c1"># transforms, it should be optimized (for example in Cython).</span>

        <span class="c1"># Get xyz once since it&#39;s an expensive operation</span>
        <span class="n">oldxyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span>
        <span class="c1"># Note that neither dot nor einsum handles Quantity properly, so we use</span>
        <span class="c1"># the arrays and put the unit back in the end.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isscalar</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">matrix_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
            <span class="c1"># a fast path for scalar coordinates.</span>
            <span class="n">newxyz</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">oldxyz</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Matrix multiply all pmat items and coordinates, broadcasting the</span>
            <span class="c1"># remaining dimensions.</span>
            <span class="n">newxyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...ij,j...-&gt;i...&#39;</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">oldxyz</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="n">newxyz</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">newxyz</span><span class="p">,</span> <span class="n">oldxyz</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Handle differentials attached to this representation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
            <span class="c1"># TODO: speed this up going via d.d_xyz.</span>
            <span class="n">new_diffs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">matrix</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_diffs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">newxyz</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="n">new_diffs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_c</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_c</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span> <span class="k">else</span>
                         <span class="p">(</span><span class="n">other_c</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">component</span><span class="p">),</span>
                                   <span class="nb">getattr</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">component</span><span class="p">))</span>
                                <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">first</span><span class="o">.</span><span class="n">components</span><span class="p">))</span>

<div class="viewcode-block" id="CartesianRepresentation.mean"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector mean.</span>

<span class="sd">        Returns a new CartesianRepresentation instance with the means of the</span>
<span class="sd">        x, y, and z components.</span>

<span class="sd">        Refer to `~numpy.mean` for full documentation of the arguments, noting</span>
<span class="sd">        that ``axis`` is the entry in the ``shape`` of the representation, and</span>
<span class="sd">        that the ``out`` argument cannot be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CartesianRepresentation.sum"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector sum.</span>

<span class="sd">        Returns a new CartesianRepresentation instance with the sums of the</span>
<span class="sd">        x, y, and z components.</span>

<span class="sd">        Refer to `~numpy.sum` for full documentation of the arguments, noting</span>
<span class="sd">        that ``axis`` is the entry in the ``shape`` of the representation, and</span>
<span class="sd">        that the ``out`` argument cannot be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CartesianRepresentation.dot"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.dot">[docs]</a>    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dot product of two representations.</span>

<span class="sd">        Note that any associated differentials will be dropped during this</span>
<span class="sd">        operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : representation</span>
<span class="sd">            If not already cartesian, it is converted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dot_product : `~astropy.units.Quantity`</span>
<span class="sd">            The sum of the product of the x, y, and z components of ``self``</span>
<span class="sd">            and ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_c</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot only take dot product with another &quot;</span>
                            <span class="s2">&quot;representation, not a </span><span class="si">{0}</span><span class="s2"> instance.&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
                                <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span> <span class="o">*</span>
                                 <span class="nb">getattr</span><span class="p">(</span><span class="n">other_c</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">))</span></div>

<div class="viewcode-block" id="CartesianRepresentation.cross"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.cross">[docs]</a>    <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cross product of two representations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : representation</span>
<span class="sd">            If not already cartesian, it is converted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cross_product : `~astropy.coordinates.CartesianRepresentation`</span>
<span class="sd">            With vectors perpendicular to both ``self`` and ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;cross&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_c</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot only take cross product with another &quot;</span>
                            <span class="s2">&quot;representation, not a </span><span class="si">{0}</span><span class="s2"> instance.&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">other_c</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">other_c</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">other_c</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">other_c</span><span class="o">.</span><span class="n">z</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">other_c</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">other_c</span><span class="o">.</span><span class="n">x</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="UnitSphericalRepresentation"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation">[docs]</a><span class="k">class</span> <span class="nc">UnitSphericalRepresentation</span><span class="p">(</span><span class="n">BaseRepresentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of points on a unit sphere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lon, lat : `~astropy.units.Quantity` or str</span>
<span class="sd">        The longitude and latitude of the point(s), in angular units. The</span>
<span class="sd">        latitude should be between -90 and 90 degrees, and the longitude will</span>
<span class="sd">        be wrapped to an angle between 0 and 360 degrees. These can also be</span>
<span class="sd">        instances of `~astropy.coordinates.Angle`,</span>
<span class="sd">        `~astropy.coordinates.Longitude`, or `~astropy.coordinates.Latitude`.</span>

<span class="sd">    differentials : dict, `BaseDifferential`, optional</span>
<span class="sd">        Any differential classes that should be associated with this</span>
<span class="sd">        representation. The input must either be a single `BaseDifferential`</span>
<span class="sd">        instance (see `._compatible_differentials` for valid types), or a</span>
<span class="sd">        dictionary of of differential instances with keys set to a string</span>
<span class="sd">        representation of the SI unit with which the differential (derivative)</span>
<span class="sd">        is taken. For example, for a velocity differential on a positional</span>
<span class="sd">        representation, the key would be ``&#39;s&#39;`` for seconds, indicating that</span>
<span class="sd">        the derivative is a time derivative.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attr_classes</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">Longitude</span><span class="p">),</span>
                                <span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">Latitude</span><span class="p">)])</span>
    <span class="n">recommended_units</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">}</span>

    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">_dimensional_representation</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SphericalRepresentation</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UnitSphericalRepresentation</span><span class="p">,</span>
              <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="n">differentials</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_compatible_differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">UnitSphericalDifferential</span><span class="p">,</span> <span class="n">UnitSphericalCosLatDifferential</span><span class="p">,</span>
                <span class="n">SphericalDifferential</span><span class="p">,</span> <span class="n">SphericalCosLatDifferential</span><span class="p">,</span>
                <span class="n">RadialDifferential</span><span class="p">]</span>

    <span class="c1"># Could let the metaclass define these automatically, but good to have</span>
    <span class="c1"># a bit clearer docstrings.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The longitude of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The latitude of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span>

<div class="viewcode-block" id="UnitSphericalRepresentation.unit_vectors"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.unit_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">unit_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sinlon</span><span class="p">,</span> <span class="n">coslon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">sinlat</span><span class="p">,</span> <span class="n">coslat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">((</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="o">-</span><span class="n">sinlon</span><span class="p">,</span> <span class="n">coslon</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)),</span>
             <span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="o">-</span><span class="n">sinlat</span><span class="o">*</span><span class="n">coslon</span><span class="p">,</span> <span class="o">-</span><span class="n">sinlat</span><span class="o">*</span><span class="n">sinlon</span><span class="p">,</span>
                                             <span class="n">coslat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">))))</span></div>

<div class="viewcode-block" id="UnitSphericalRepresentation.scale_factors"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omit_coslat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">sf_lat</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">u</span><span class="o">.</span><span class="n">radian</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">sf_lon</span> <span class="o">=</span> <span class="n">sf_lat</span> <span class="k">if</span> <span class="n">omit_coslat</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">radian</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(((</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">sf_lon</span><span class="p">),</span>
                            <span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">sf_lat</span><span class="p">)))</span></div>

<div class="viewcode-block" id="UnitSphericalRepresentation.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts spherical polar coordinates to 3D rectangular cartesian</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="UnitSphericalRepresentation.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.from_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts 3D rectangular cartesian coordinates to spherical polar</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">cart</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">cart</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">cart</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitSphericalRepresentation.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">differential_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Take a short cut if the other class is a spherical representation</span>

        <span class="c1"># TODO: this could be optimized to shortcut even if a differential_class</span>
        <span class="c1"># is passed in, using the ._re_represent_differentials() method</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">differential_class</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">PhysicsSphericalRepresentation</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">phi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">90</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                   <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">SphericalRepresentation</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                   <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">UnitSphericalRepresentation</span><span class="p">,</span>
                     <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">differential_class</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;multiplication&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensional_representation</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span>
                                                <span class="n">distance</span><span class="o">=</span><span class="mf">1.</span> <span class="o">*</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;division&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensional_representation</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span>
                                                <span class="n">distance</span><span class="o">=</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;negation&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span> <span class="o">+</span> <span class="mf">180.</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="UnitSphericalRepresentation.norm"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector norm.</span>

<span class="sd">        The norm is the standard Frobenius norm, i.e., the square root of the</span>
<span class="sd">        sum of the squares of all components with non-angular units, which is</span>
<span class="sd">        always unity for vectors on the unit sphere.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : `~astropy.units.Quantity`</span>
<span class="sd">            Dimensionless ones, with the same shape as the representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">,</span>
                          <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensional_representation</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<div class="viewcode-block" id="UnitSphericalRepresentation.mean"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector mean.</span>

<span class="sd">        The representation is converted to cartesian, the means of the x, y,</span>
<span class="sd">        and z components are calculated, and the result is converted to a</span>
<span class="sd">        `~astropy.coordinates.SphericalRepresentation`.</span>

<span class="sd">        Refer to `~numpy.mean` for full documentation of the arguments, noting</span>
<span class="sd">        that ``axis`` is the entry in the ``shape`` of the representation, and</span>
<span class="sd">        that the ``out`` argument cannot be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensional_representation</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="UnitSphericalRepresentation.sum"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector sum.</span>

<span class="sd">        The representation is converted to cartesian, the sums of the x, y,</span>
<span class="sd">        and z components are calculated, and the result is converted to a</span>
<span class="sd">        `~astropy.coordinates.SphericalRepresentation`.</span>

<span class="sd">        Refer to `~numpy.sum` for full documentation of the arguments, noting</span>
<span class="sd">        that ``axis`` is the entry in the ``shape`` of the representation, and</span>
<span class="sd">        that the ``out`` argument cannot be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensional_representation</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="UnitSphericalRepresentation.cross"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.cross">[docs]</a>    <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cross product of two representations.</span>

<span class="sd">        The calculation is done by converting both ``self`` and ``other``</span>
<span class="sd">        to `~astropy.coordinates.CartesianRepresentation`, and converting the</span>
<span class="sd">        result back to `~astropy.coordinates.SphericalRepresentation`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : representation</span>
<span class="sd">            The representation to take the cross product with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cross_product : `~astropy.coordinates.SphericalRepresentation`</span>
<span class="sd">            With vectors perpendicular to both ``self`` and ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;cross&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensional_representation</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">other</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="RadialRepresentation"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialRepresentation.html#astropy.coordinates.RadialRepresentation">[docs]</a><span class="k">class</span> <span class="nc">RadialRepresentation</span><span class="p">(</span><span class="n">BaseRepresentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of the distance of points from the origin.</span>

<span class="sd">    Note that this is mostly intended as an internal helper representation.</span>
<span class="sd">    It can do little else but being used as a scale in multiplication.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    distance : `~astropy.units.Quantity`</span>
<span class="sd">        The distance of the point(s) from the origin.</span>

<span class="sd">    differentials : dict, `BaseDifferential`, optional</span>
<span class="sd">        Any differential classes that should be associated with this</span>
<span class="sd">        representation. The input must either be a single `BaseDifferential`</span>
<span class="sd">        instance (see `._compatible_differentials` for valid types), or a</span>
<span class="sd">        dictionary of of differential instances with keys set to a string</span>
<span class="sd">        representation of the SI unit with which the differential (derivative)</span>
<span class="sd">        is taken. For example, for a velocity differential on a positional</span>
<span class="sd">        representation, the key would be ``&#39;s&#39;`` for seconds, indicating that</span>
<span class="sd">        the derivative is a time derivative.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attr_classes</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RadialRepresentation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                                                   <span class="n">differentials</span><span class="o">=</span><span class="n">differentials</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The distance from the origin to the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span>

<div class="viewcode-block" id="RadialRepresentation.unit_vectors"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialRepresentation.html#astropy.coordinates.RadialRepresentation.unit_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">unit_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cartesian unit vectors are undefined for radial representation.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cartesian unit vectors are undefined for &#39;</span>
                                  <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> instances&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">))</span></div>

<div class="viewcode-block" id="RadialRepresentation.scale_factors"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialRepresentation.html#astropy.coordinates.RadialRepresentation.scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(((</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">l</span><span class="p">),))</span></div>

<div class="viewcode-block" id="RadialRepresentation.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialRepresentation.html#astropy.coordinates.RadialRepresentation.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cannot convert radial representation to cartesian.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;cannot convert </span><span class="si">{0}</span><span class="s1"> instance to cartesian.&#39;</span>
                                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">))</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="RadialRepresentation.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialRepresentation.html#astropy.coordinates.RadialRepresentation.from_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts 3D rectangular cartesian coordinates to radial coordinate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">distance</span><span class="o">=</span><span class="n">cart</span><span class="o">.</span><span class="n">norm</span><span class="p">(),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

<div class="viewcode-block" id="RadialRepresentation.norm"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialRepresentation.html#astropy.coordinates.RadialRepresentation.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector norm.</span>

<span class="sd">        Just the distance itself.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : `~astropy.units.Quantity`</span>
<span class="sd">            Dimensionless ones, with the same shape as the representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span></div>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span></div>


<div class="viewcode-block" id="SphericalRepresentation"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation">[docs]</a><span class="k">class</span> <span class="nc">SphericalRepresentation</span><span class="p">(</span><span class="n">BaseRepresentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of points in 3D spherical coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lon, lat : `~astropy.units.Quantity`</span>
<span class="sd">        The longitude and latitude of the point(s), in angular units. The</span>
<span class="sd">        latitude should be between -90 and 90 degrees, and the longitude will</span>
<span class="sd">        be wrapped to an angle between 0 and 360 degrees. These can also be</span>
<span class="sd">        instances of `~astropy.coordinates.Angle`,</span>
<span class="sd">        `~astropy.coordinates.Longitude`, or `~astropy.coordinates.Latitude`.</span>

<span class="sd">    distance : `~astropy.units.Quantity`</span>
<span class="sd">        The distance to the point(s). If the distance is a length, it is</span>
<span class="sd">        passed to the :class:`~astropy.coordinates.Distance` class, otherwise</span>
<span class="sd">        it is passed to the :class:`~astropy.units.Quantity` class.</span>

<span class="sd">    differentials : dict, `BaseDifferential`, optional</span>
<span class="sd">        Any differential classes that should be associated with this</span>
<span class="sd">        representation. The input must either be a single `BaseDifferential`</span>
<span class="sd">        instance (see `._compatible_differentials` for valid types), or a</span>
<span class="sd">        dictionary of of differential instances with keys set to a string</span>
<span class="sd">        representation of the SI unit with which the differential (derivative)</span>
<span class="sd">        is taken. For example, for a velocity differential on a positional</span>
<span class="sd">        representation, the key would be ``&#39;s&#39;`` for seconds, indicating that</span>
<span class="sd">        the derivative is a time derivative.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attr_classes</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">Longitude</span><span class="p">),</span>
                                <span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">Latitude</span><span class="p">),</span>
                                <span class="p">(</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)])</span>
    <span class="n">recommended_units</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">}</span>
    <span class="n">_unit_representation</span> <span class="o">=</span> <span class="n">UnitSphericalRepresentation</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SphericalRepresentation</span><span class="p">,</span>
              <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                             <span class="n">differentials</span><span class="o">=</span><span class="n">differentials</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">physical_type</span> <span class="o">==</span> <span class="s1">&#39;length&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">Distance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_compatible_differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">UnitSphericalDifferential</span><span class="p">,</span> <span class="n">UnitSphericalCosLatDifferential</span><span class="p">,</span>
                <span class="n">SphericalDifferential</span><span class="p">,</span> <span class="n">SphericalCosLatDifferential</span><span class="p">,</span>
                <span class="n">RadialDifferential</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The longitude of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The latitude of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The distance from the origin to the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span>

<div class="viewcode-block" id="SphericalRepresentation.unit_vectors"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation.unit_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">unit_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sinlon</span><span class="p">,</span> <span class="n">coslon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">sinlat</span><span class="p">,</span> <span class="n">coslat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">((</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="o">-</span><span class="n">sinlon</span><span class="p">,</span> <span class="n">coslon</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)),</span>
             <span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="o">-</span><span class="n">sinlat</span><span class="o">*</span><span class="n">coslon</span><span class="p">,</span> <span class="o">-</span><span class="n">sinlat</span><span class="o">*</span><span class="n">sinlon</span><span class="p">,</span>
                                             <span class="n">coslat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)),</span>
             <span class="p">(</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">coslat</span><span class="o">*</span><span class="n">coslon</span><span class="p">,</span> <span class="n">coslat</span><span class="o">*</span><span class="n">sinlon</span><span class="p">,</span>
                                                  <span class="n">sinlat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">))))</span></div>

<div class="viewcode-block" id="SphericalRepresentation.scale_factors"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation.scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omit_coslat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">sf_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">radian</span>
        <span class="n">sf_lon</span> <span class="o">=</span> <span class="n">sf_lat</span> <span class="k">if</span> <span class="n">omit_coslat</span> <span class="k">else</span> <span class="n">sf_lat</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">sf_distance</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(((</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span> <span class="n">sf_lon</span><span class="p">),</span>
                            <span class="p">(</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="n">sf_lat</span><span class="p">),</span>
                            <span class="p">(</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">sf_distance</span><span class="p">)))</span></div>

<div class="viewcode-block" id="SphericalRepresentation.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">differential_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Take a short cut if the other class is a spherical representation</span>

        <span class="c1"># TODO: this could be optimized to shortcut even if a differential_class</span>
        <span class="c1"># is passed in, using the ._re_represent_differentials() method</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">differential_class</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">PhysicsSphericalRepresentation</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">phi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">90</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span>
                                   <span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalRepresentation</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SphericalRepresentation</span><span class="p">,</span>
                     <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">differential_class</span><span class="p">)</span></div>

<div class="viewcode-block" id="SphericalRepresentation.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts spherical polar coordinates to 3D rectangular cartesian</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We need to convert Distance to Quantity to allow negative values.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">Distance</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="SphericalRepresentation.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation.from_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts 3D rectangular cartesian coordinates to spherical polar</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">cart</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

        <span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">cart</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">cart</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SphericalRepresentation.norm"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector norm.</span>

<span class="sd">        The norm is the standard Frobenius norm, i.e., the square root of the</span>
<span class="sd">        sum of the squares of all components with non-angular units.  For</span>
<span class="sd">        spherical coordinates, this is just the absolute value of the distance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : `astropy.units.Quantity`</span>
<span class="sd">            Vector norm, with the same shape as the representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PhysicsSphericalRepresentation"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation">[docs]</a><span class="k">class</span> <span class="nc">PhysicsSphericalRepresentation</span><span class="p">(</span><span class="n">BaseRepresentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of points in 3D spherical coordinates (using the physics</span>
<span class="sd">    convention of using ``phi`` and ``theta`` for azimuth and inclination</span>
<span class="sd">    from the pole).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    phi, theta : `~astropy.units.Quantity` or str</span>
<span class="sd">        The azimuth and inclination of the point(s), in angular units. The</span>
<span class="sd">        inclination should be between 0 and 180 degrees, and the azimuth will</span>
<span class="sd">        be wrapped to an angle between 0 and 360 degrees. These can also be</span>
<span class="sd">        instances of `~astropy.coordinates.Angle`.  If ``copy`` is False, `phi`</span>
<span class="sd">        will be changed inplace if it is not between 0 and 360 degrees.</span>

<span class="sd">    r : `~astropy.units.Quantity`</span>
<span class="sd">        The distance to the point(s). If the distance is a length, it is</span>
<span class="sd">        passed to the :class:`~astropy.coordinates.Distance` class, otherwise</span>
<span class="sd">        it is passed to the :class:`~astropy.units.Quantity` class.</span>

<span class="sd">    differentials : dict, `PhysicsSphericalDifferential`, optional</span>
<span class="sd">        Any differential classes that should be associated with this</span>
<span class="sd">        representation. The input must either be a single</span>
<span class="sd">        `PhysicsSphericalDifferential` instance, or a dictionary of of</span>
<span class="sd">        differential instances with keys set to a string representation of the</span>
<span class="sd">        SI unit with which the differential (derivative) is taken. For example,</span>
<span class="sd">        for a velocity differential on a positional representation, the key</span>
<span class="sd">        would be ``&#39;s&#39;`` for seconds, indicating that the derivative is a time</span>
<span class="sd">        derivative.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attr_classes</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="n">Angle</span><span class="p">),</span>
                                <span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">,</span> <span class="n">Angle</span><span class="p">),</span>
                                <span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)])</span>
    <span class="n">recommended_units</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;phi&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PhysicsSphericalRepresentation</span><span class="p">,</span>
              <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                             <span class="n">differentials</span><span class="o">=</span><span class="n">differentials</span><span class="p">)</span>

        <span class="c1"># Wrap/validate phi/theta</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phi</span><span class="o">.</span><span class="n">wrap_at</span><span class="p">(</span><span class="mi">360</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># necessary because the above version of `wrap_at` has to be a copy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_phi</span><span class="o">.</span><span class="n">wrap_at</span><span class="p">(</span><span class="mi">360</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_theta</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_theta</span> <span class="o">&gt;</span> <span class="mf">180.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Inclination angle(s) must be within &#39;</span>
                             <span class="s1">&#39;0 deg &lt;= angle &lt;= 180 deg, &#39;</span>
                             <span class="s1">&#39;got </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">physical_type</span> <span class="o">==</span> <span class="s1">&#39;length&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">Distance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The azimuth of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phi</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">theta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The elevation of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The distance from the origin to the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r</span>

<div class="viewcode-block" id="PhysicsSphericalRepresentation.unit_vectors"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation.unit_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">unit_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sinphi</span><span class="p">,</span> <span class="n">cosphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">sintheta</span><span class="p">,</span> <span class="n">costheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">((</span><span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="o">-</span><span class="n">sinphi</span><span class="p">,</span> <span class="n">cosphi</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)),</span>
             <span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">costheta</span><span class="o">*</span><span class="n">cosphi</span><span class="p">,</span>
                                               <span class="n">costheta</span><span class="o">*</span><span class="n">sinphi</span><span class="p">,</span>
                                               <span class="o">-</span><span class="n">sintheta</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)),</span>
             <span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">sintheta</span><span class="o">*</span><span class="n">cosphi</span><span class="p">,</span> <span class="n">sintheta</span><span class="o">*</span><span class="n">sinphi</span><span class="p">,</span>
                                           <span class="n">costheta</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">))))</span></div>

<div class="viewcode-block" id="PhysicsSphericalRepresentation.scale_factors"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation.scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">radian</span>
        <span class="n">sintheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(((</span><span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span> <span class="n">sintheta</span><span class="p">),</span>
                            <span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span>
                            <span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">l</span><span class="p">)))</span></div>

<div class="viewcode-block" id="PhysicsSphericalRepresentation.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">differential_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Take a short cut if the other class is a spherical representation</span>

        <span class="c1"># TODO: this could be optimized to shortcut even if a differential_class</span>
        <span class="c1"># is passed in, using the ._re_represent_differentials() method</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">differential_class</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">SphericalRepresentation</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="mi">90</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span>
                                   <span class="n">distance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalRepresentation</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="mi">90</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">PhysicsSphericalRepresentation</span><span class="p">,</span>
                     <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">differential_class</span><span class="p">)</span></div>

<div class="viewcode-block" id="PhysicsSphericalRepresentation.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts spherical polar coordinates to 3D rectangular cartesian</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We need to convert Distance to Quantity to allow negative values.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">Distance</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="PhysicsSphericalRepresentation.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation.from_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts 3D rectangular cartesian coordinates to spherical polar</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">cart</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">cart</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="PhysicsSphericalRepresentation.norm"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector norm.</span>

<span class="sd">        The norm is the standard Frobenius norm, i.e., the square root of the</span>
<span class="sd">        sum of the squares of all components with non-angular units.  For</span>
<span class="sd">        spherical coordinates, this is just the absolute value of the radius.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : `astropy.units.Quantity`</span>
<span class="sd">            Vector norm, with the same shape as the representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CylindricalRepresentation"><a class="viewcode-back" href="../../../api/astropy.coordinates.CylindricalRepresentation.html#astropy.coordinates.CylindricalRepresentation">[docs]</a><span class="k">class</span> <span class="nc">CylindricalRepresentation</span><span class="p">(</span><span class="n">BaseRepresentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of points in 3D cylindrical coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rho : `~astropy.units.Quantity`</span>
<span class="sd">        The distance from the z axis to the point(s).</span>

<span class="sd">    phi : `~astropy.units.Quantity` or str</span>
<span class="sd">        The azimuth of the point(s), in angular units, which will be wrapped</span>
<span class="sd">        to an angle between 0 and 360 degrees. This can also be instances of</span>
<span class="sd">        `~astropy.coordinates.Angle`,</span>

<span class="sd">    z : `~astropy.units.Quantity`</span>
<span class="sd">        The z coordinate(s) of the point(s)</span>

<span class="sd">    differentials : dict, `CylindricalDifferential`, optional</span>
<span class="sd">        Any differential classes that should be associated with this</span>
<span class="sd">        representation. The input must either be a single</span>
<span class="sd">        `CylindricalDifferential` instance, or a dictionary of of differential</span>
<span class="sd">        instances with keys set to a string representation of the SI unit with</span>
<span class="sd">        which the differential (derivative) is taken. For example, for a</span>
<span class="sd">        velocity differential on a positional representation, the key would be</span>
<span class="sd">        ``&#39;s&#39;`` for seconds, indicating that the derivative is a time</span>
<span class="sd">        derivative.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attr_classes</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">),</span>
                                <span class="p">(</span><span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="n">Angle</span><span class="p">),</span>
                                <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)])</span>
    <span class="n">recommended_units</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;phi&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CylindricalRepresentation</span><span class="p">,</span>
              <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                             <span class="n">differentials</span><span class="o">=</span><span class="n">differentials</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rho</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_z</span><span class="o">.</span><span class="n">unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;rho and z should have matching physical types&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The distance of the point(s) from the z-axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rho</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The azimuth of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phi</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The height of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z</span>

<div class="viewcode-block" id="CylindricalRepresentation.unit_vectors"><a class="viewcode-back" href="../../../api/astropy.coordinates.CylindricalRepresentation.html#astropy.coordinates.CylindricalRepresentation.unit_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">unit_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sinphi</span><span class="p">,</span> <span class="n">cosphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">((</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">cosphi</span><span class="p">,</span> <span class="n">sinphi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)),</span>
             <span class="p">(</span><span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="o">-</span><span class="n">sinphi</span><span class="p">,</span> <span class="n">cosphi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)),</span>
             <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">))))</span></div>

<div class="viewcode-block" id="CylindricalRepresentation.scale_factors"><a class="viewcode-back" href="../../../api/astropy.coordinates.CylindricalRepresentation.html#astropy.coordinates.CylindricalRepresentation.scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">radian</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(((</span><span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span>
                            <span class="p">(</span><span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="n">rho</span><span class="p">),</span>
                            <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">l</span><span class="p">)))</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="CylindricalRepresentation.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.CylindricalRepresentation.html#astropy.coordinates.CylindricalRepresentation.from_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts 3D rectangular cartesian coordinates to cylindrical polar</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">cart</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">cart</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">cart</span><span class="o">.</span><span class="n">z</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="CylindricalRepresentation.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.CylindricalRepresentation.html#astropy.coordinates.CylindricalRepresentation.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts cylindrical polar coordinates to 3D rectangular cartesian</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span>

        <span class="k">return</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">MetaBaseDifferential</span><span class="p">(</span><span class="n">InheritDocstrings</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set default ``attr_classes`` and component getters on a Differential.</span>

<span class="sd">    For these, the components are those of the base representation prefixed</span>
<span class="sd">    by &#39;d_&#39;, and the class is `~astropy.units.Quantity`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MetaBaseDifferential</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span>

        <span class="c1"># Don&#39;t do anything for base helper classes.</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;BaseDifferential&#39;</span><span class="p">,</span> <span class="s1">&#39;BaseSphericalDifferential&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;BaseSphericalCosLatDifferential&#39;</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="s1">&#39;base_representation&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dct</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Differential representations must have a&#39;</span>
                                      <span class="s1">&#39;&quot;base_representation&quot; class attribute.&#39;</span><span class="p">)</span>

        <span class="c1"># If not defined explicitly, create attr_classes.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="s1">&#39;attr_classes&#39;</span><span class="p">):</span>
            <span class="n">base_attr_classes</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">base_representation</span><span class="o">.</span><span class="n">attr_classes</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">attr_classes</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;d_&#39;</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)</span>
                                            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">base_attr_classes</span><span class="p">])</span>

        <span class="n">repr_name</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">repr_name</span> <span class="ow">in</span> <span class="n">DIFFERENTIAL_CLASSES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Differential class </span><span class="si">{0}</span><span class="s2"> already defined&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">repr_name</span><span class="p">))</span>

        <span class="n">DIFFERENTIAL_CLASSES</span><span class="p">[</span><span class="n">repr_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls</span>

        <span class="c1"># If not defined explicitly, create properties for the components.</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">attr_classes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span>
                        <span class="nb">property</span><span class="p">(</span><span class="n">_make_getter</span><span class="p">(</span><span class="n">component</span><span class="p">),</span>
                                 <span class="n">doc</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Component &#39;</span><span class="si">{0}</span><span class="s2">&#39; of the Differential.&quot;</span>
                                      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component</span><span class="p">))))</span>


<span class="nd">@six</span><span class="o">.</span><span class="n">add_metaclass</span><span class="p">(</span><span class="n">MetaBaseDifferential</span><span class="p">)</span>
<div class="viewcode-block" id="BaseDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseDifferential.html#astropy.coordinates.BaseDifferential">[docs]</a><span class="k">class</span> <span class="nc">BaseDifferential</span><span class="p">(</span><span class="n">BaseRepresentationOrDifferential</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;A base class representing differentials of representations.</span>

<span class="sd">    These represent differences or derivatives along each component.</span>
<span class="sd">    E.g., for physics spherical coordinates, these would be</span>
<span class="sd">    :math:`\delta r, \delta \theta, \delta \phi`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_comp1, d_comp2, d_comp3 : `~astropy.units.Quantity` or subclass</span>
<span class="sd">        The components of the 3D differentials.  The names are the keys and the</span>
<span class="sd">        subclasses the values of the ``attr_classes`` attribute.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    All differential representation classes should subclass this base class,</span>
<span class="sd">    and define an ``base_representation`` attribute with the class of the</span>
<span class="sd">    regular `~astropy.coordinates.BaseRepresentation` for which differential</span>
<span class="sd">    coordinates are provided. This will set up a default ``attr_classes``</span>
<span class="sd">    instance with names equal to the base component names prefixed by ``d_``,</span>
<span class="sd">    and all classes set to `~astropy.units.Quantity`, plus properties to access</span>
<span class="sd">    those, and a default ``__init__`` for initialization.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">recommended_units</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># subclasses can override</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_check_base</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">_compatible_differentials</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Differential class </span><span class="si">{0}</span><span class="s2"> is not compatible with the &quot;</span>
                            <span class="s2">&quot;base (representation) class </span><span class="si">{1}</span><span class="s2">&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">__class__</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_deriv_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a base (representation instance), determine the unit of the</span>
<span class="sd">        derivative by removing the representation unit from the component units</span>
<span class="sd">        of this differential.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This check is just a last resort so we don&#39;t return a strange unit key</span>
        <span class="c1"># from accidentally passing in the wrong base.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">d_comp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;d_</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d_comp</span><span class="p">:</span>
                <span class="n">d_unit</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">unit</span> <span class="o">/</span> <span class="n">d_comp</span><span class="o">.</span><span class="n">unit</span>
                <span class="c1"># Get the si unit without a scale by going via Quantity;</span>
                <span class="c1"># `.si` causes the scale to be included in the value.</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">d_unit</span><span class="p">)</span><span class="o">.</span><span class="n">si</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Invalid representation-differential match! Not &quot;</span>
                               <span class="s2">&quot;sure how we got into this state.&quot;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_base_vectors</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get unit vectors and scale factors from base.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : instance of ``self.base_representation``</span>
<span class="sd">            The points for which the unit vectors and scale factors should be</span>
<span class="sd">            retrieved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unit_vectors : dict of `CartesianRepresentation`</span>
<span class="sd">            In the directions of the coordinates of base.</span>
<span class="sd">        scale_factors : dict of `~astropy.units.Quantity`</span>
<span class="sd">            Scale factors for each of the coordinates</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError : if the base is not of the correct type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">unit_vectors</span><span class="p">(),</span> <span class="n">base</span><span class="o">.</span><span class="n">scale_factors</span><span class="p">()</span>

<div class="viewcode-block" id="BaseDifferential.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseDifferential.html#astropy.coordinates.BaseDifferential.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the differential to 3D rectangular cartesian coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : instance of ``self.base_representation``</span>
<span class="sd">             The points for which the differentials are to be converted: each of</span>
<span class="sd">             the components is multiplied by its unit vectors and scale factors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        This object as a `CartesianDifferential`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base_e</span><span class="p">,</span> <span class="n">base_sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_base_vectors</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_c</span><span class="p">)</span> <span class="o">*</span> <span class="n">base_sf</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">base_e</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                           <span class="k">for</span> <span class="n">d_c</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">components</span><span class="p">)))</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="BaseDifferential.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseDifferential.html#astropy.coordinates.BaseDifferential.from_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the differential from 3D rectangular cartesian coordinates to</span>
<span class="sd">        the desired class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other :</span>
<span class="sd">            The object to convert into this differential.</span>
<span class="sd">        base : instance of ``self.base_representation``</span>
<span class="sd">             The points for which the differentials are to be converted: each of</span>
<span class="sd">             the components is multiplied by its unit vectors and scale factors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A new differential object that is this class&#39; type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base_e</span><span class="p">,</span> <span class="n">base_sf</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_get_base_vectors</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">e</span> <span class="o">/</span> <span class="n">base_sf</span><span class="p">[</span><span class="n">component</span><span class="p">])</span>
                     <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">base_e</span><span class="p">)),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseDifferential.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseDifferential.html#astropy.coordinates.BaseDifferential.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert coordinates to another representation.</span>

<span class="sd">        If the instance is of the requested class, it is returned unmodified.</span>
<span class="sd">        By default, conversion is done via cartesian coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other_class : `~astropy.coordinates.BaseRepresentation` subclass</span>
<span class="sd">            The type of representation to turn the coordinates into.</span>
<span class="sd">        base : instance of ``self.base_representation``, optional</span>
<span class="sd">            Base relative to which the differentials are defined.  If the other</span>
<span class="sd">            class is a differential representation, the base will be converted</span>
<span class="sd">            to its ``base_representation``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other_class</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># The default is to convert via cartesian coordinates.</span>
        <span class="n">self_cartesian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">BaseDifferential</span><span class="p">):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="o">.</span><span class="n">base_representation</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="n">self_cartesian</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="n">self_cartesian</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="BaseDifferential.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseDifferential.html#astropy.coordinates.BaseDifferential.from_representation">[docs]</a>    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new instance of this representation from another one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        representation : `~astropy.coordinates.BaseRepresentation` instance</span>
<span class="sd">            The presentation that should be converted to this class.</span>
<span class="sd">        base : instance of ``cls.base_representation``</span>
<span class="sd">            The base relative to which the differentials will be defined. If</span>
<span class="sd">            the representation is a differential itself, the base will be</span>
<span class="sd">            converted to its ``base_representation`` to help convert it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">BaseDifferential</span><span class="p">):</span>
            <span class="n">cartesian</span> <span class="o">=</span> <span class="n">representation</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span>
                <span class="n">base</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">base_representation</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cartesian</span> <span class="o">=</span> <span class="n">representation</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="n">cartesian</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scale all components.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op : `~operator` callable</span>
<span class="sd">            Operator to apply (e.g., `~operator.mul`, `~operator.neg`, etc.</span>
<span class="sd">        *args</span>
<span class="sd">            Any arguments required for the operator (typically, what is to</span>
<span class="sd">            be multiplied with, divided by).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaled_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">scaled_attrs</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine two differentials, or a differential with a representation.</span>

<span class="sd">        If ``other`` is of the same differential type as ``self``, the</span>
<span class="sd">        components will simply be combined.  If ``other`` is a representation,</span>
<span class="sd">        it will be used as a base for which to evaluate the differential,</span>
<span class="sd">        and the result is a new representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op : `~operator` callable</span>
<span class="sd">            Operator to apply (e.g., `~operator.add`, `~operator.sub`, etc.</span>
<span class="sd">        other : `~astropy.coordinates.BaseRepresentation` instance</span>
<span class="sd">            The other differential or representation.</span>
<span class="sd">        reverse : bool</span>
<span class="sd">            Whether the operands should be reversed (e.g., as we got here via</span>
<span class="sd">            ``self.__rsub__`` because ``self`` is a subclass of ``other``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)):</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span> <span class="k">else</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
                                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">self_cartesian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">self_cartesian</span><span class="p">,</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># avoid &quot;differential - representation&quot;.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseRepresentation</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BaseDifferential</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__sub__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="BaseDifferential.norm"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseDifferential.html#astropy.coordinates.BaseDifferential.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector norm.</span>

<span class="sd">        The norm is the standard Frobenius norm, i.e., the square root of the</span>
<span class="sd">        sum of the squares of all components with non-angular units.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : instance of ``self.base_representation``</span>
<span class="sd">            Base relative to which the differentials are defined. This is</span>
<span class="sd">            required to calculate the physical size of the differential for</span>
<span class="sd">            all but cartesian differentials.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : `astropy.units.Quantity`</span>
<span class="sd">            Vector norm, with the same shape as the representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="n">base</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="CartesianDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianDifferential.html#astropy.coordinates.CartesianDifferential">[docs]</a><span class="k">class</span> <span class="nc">CartesianDifferential</span><span class="p">(</span><span class="n">BaseDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differentials in of points in 3D cartesian coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_x, d_y, d_z : `~astropy.units.Quantity` or array</span>
<span class="sd">        The x, y, and z coordinates of the differentials. If ``d_x``, ``d_y``,</span>
<span class="sd">        and ``d_z`` have different shapes, they should be broadcastable. If not</span>
<span class="sd">        quantities, ``unit`` should be set.  If only ``d_x`` is given, it is</span>
<span class="sd">        assumed that it contains an array with the 3 coordinates stored along</span>
<span class="sd">        ``xyz_axis``.</span>
<span class="sd">    unit : `~astropy.units.Unit` or str</span>
<span class="sd">        If given, the differentials will be converted to this unit (or taken to</span>
<span class="sd">        be in this unit if not given.</span>
<span class="sd">    xyz_axis : int, optional</span>
<span class="sd">        The axis along which the coordinates are stored when a single array is</span>
<span class="sd">        provided instead of distinct ``d_x``, ``d_y``, and ``d_z`` (default: 0).</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">CartesianRepresentation</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_x</span><span class="p">,</span> <span class="n">d_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d_z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">d_y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">d_z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">xyz_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">xyz_axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">d_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">d_x</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">d_x</span><span class="p">,</span> <span class="n">d_y</span><span class="p">,</span> <span class="n">d_z</span> <span class="o">=</span> <span class="n">d_x</span>
        <span class="k">elif</span> <span class="n">xyz_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;xyz_axis should only be set if d_x, d_y, and d_z &quot;</span>
                             <span class="s2">&quot;are in a single array passed in through d_x, &quot;</span>
                             <span class="s2">&quot;i.e., d_y and d_z should not be not given.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">((</span><span class="n">d_y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">d_z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>
              <span class="p">(</span><span class="n">d_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">d_z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;d_x, d_y, and d_z are required to instantiate </span><span class="si">{0}</span><span class="s2">&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d_x</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">d_x</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">d_y</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">d_y</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">d_z</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">d_z</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">CartesianDifferential</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">d_x</span><span class="p">,</span> <span class="n">d_y</span><span class="p">,</span> <span class="n">d_z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_x</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_y</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_d_x</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_z</span><span class="o">.</span><span class="n">unit</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s1">&#39;d_x, d_y and d_z should have equivalent units.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="CartesianDifferential.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianDifferential.html#astropy.coordinates.CartesianDifferential.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span>
                                         <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">])</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="CartesianDifferential.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianDifferential.html#astropy.coordinates.CartesianDifferential.from_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">components</span><span class="p">])</span></div>

<div class="viewcode-block" id="CartesianDifferential.get_d_xyz"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianDifferential.html#astropy.coordinates.CartesianDifferential.get_d_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">get_d_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a vector array of the x, y, and z coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz_axis : int, optional</span>
<span class="sd">            The axis in the final array along which the x, y, z components</span>
<span class="sd">            should be stored (default: 0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xyz : `~astropy.units.Quantity`</span>
<span class="sd">            With dimension 3 along ``xyz_axis``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_combine_xyz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_z</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=</span><span class="n">xyz_axis</span><span class="p">)</span></div>

    <span class="n">d_xyz</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_d_xyz</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseSphericalDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseSphericalDifferential.html#astropy.coordinates.BaseSphericalDifferential">[docs]</a><span class="k">class</span> <span class="nc">BaseSphericalDifferential</span><span class="p">(</span><span class="n">BaseDifferential</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_d_lon_coslat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert longitude differential d_lon to d_lon_coslat.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : instance of ``cls.base_representation``</span>
<span class="sd">            The base from which the latitude will be taken.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lon</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_d_lon</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert longitude differential d_lon_coslat to d_lon.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d_lon_coslat : `~astropy.units.Quantity`</span>
<span class="sd">            Longitude differential that includes ``cos(lat)``.</span>
<span class="sd">        base : instance of ``cls.base_representation``</span>
<span class="sd">            The base from which the latitude will be taken.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d_lon_coslat</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine two differentials, or a differential with a representation.</span>

<span class="sd">        If ``other`` is of the same differential type as ``self``, the</span>
<span class="sd">        components will simply be combined.  If both are different parts of</span>
<span class="sd">        a `~astropy.coordinates.SphericalDifferential` (e.g., a</span>
<span class="sd">        `~astropy.coordinates.UnitSphericalDifferential` and a</span>
<span class="sd">        `~astropy.coordinates.RadialDifferential`), they will combined</span>
<span class="sd">        appropriately.</span>

<span class="sd">        If ``other`` is a representation, it will be used as a base for which</span>
<span class="sd">        to evaluate the differential, and the result is a new representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op : `~operator` callable</span>
<span class="sd">            Operator to apply (e.g., `~operator.add`, `~operator.sub`, etc.</span>
<span class="sd">        other : `~astropy.coordinates.BaseRepresentation` instance</span>
<span class="sd">            The other differential or representation.</span>
<span class="sd">        reverse : bool</span>
<span class="sd">            Whether the operands should be reversed (e.g., as we got here via</span>
<span class="sd">            ``self.__rsub__`` because ``self`` is a subclass of ``other``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseSphericalDifferential</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="ow">or</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">RadialDifferential</span><span class="p">)):</span>
            <span class="n">all_components</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span> <span class="k">else</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">result_args</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">all_components</span><span class="p">}</span>
            <span class="k">return</span> <span class="n">SphericalDifferential</span><span class="p">(</span><span class="o">**</span><span class="n">result_args</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BaseSphericalDifferential</span><span class="p">,</span>
                     <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span></div>


<div class="viewcode-block" id="UnitSphericalDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalDifferential.html#astropy.coordinates.UnitSphericalDifferential">[docs]</a><span class="k">class</span> <span class="nc">UnitSphericalDifferential</span><span class="p">(</span><span class="n">BaseSphericalDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differential(s) of points on a unit sphere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_lon, d_lat : `~astropy.units.Quantity`</span>
<span class="sd">        The longitude and latitude of the differentials.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">UnitSphericalRepresentation</span>

    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">_dimensional_differential</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SphericalDifferential</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_lon</span><span class="p">,</span> <span class="n">d_lat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UnitSphericalDifferential</span><span class="p">,</span>
              <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">d_lat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_lon</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lat</span><span class="o">.</span><span class="n">unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s1">&#39;d_lon and d_lat should have equivalent units.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="UnitSphericalDifferential.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalDifferential.html#astropy.coordinates.UnitSphericalDifferential.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">SphericalRepresentation</span><span class="p">):</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">distance</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">PhysicsSphericalRepresentation</span><span class="p">):</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">UnitSphericalDifferential</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

        <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">UnitSphericalRepresentation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scale</span> <span class="o">*</span> <span class="nb">super</span><span class="p">(</span><span class="n">UnitSphericalDifferential</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="n">base</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitSphericalDifferential.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalDifferential.html#astropy.coordinates.UnitSphericalDifferential.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Only have enough information to represent other unit-spherical.</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalCosLatDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lon_coslat</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">UnitSphericalDifferential</span><span class="p">,</span>
                     <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="UnitSphericalDifferential.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalDifferential.html#astropy.coordinates.UnitSphericalDifferential.from_representation">[docs]</a>    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># All spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though CosLat needs base for the latitude.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">SphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="p">(</span><span class="n">SphericalCosLatDifferential</span><span class="p">,</span>
                                         <span class="n">UnitSphericalCosLatDifferential</span><span class="p">)):</span>
            <span class="n">d_lon</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_get_d_lon</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">PhysicsSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_phi</span><span class="p">,</span> <span class="o">-</span><span class="n">representation</span><span class="o">.</span><span class="n">d_theta</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">UnitSphericalDifferential</span><span class="p">,</span>
                     <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_representation</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SphericalDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalDifferential.html#astropy.coordinates.SphericalDifferential">[docs]</a><span class="k">class</span> <span class="nc">SphericalDifferential</span><span class="p">(</span><span class="n">BaseSphericalDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differential(s) of points in 3D spherical coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_lon, d_lat : `~astropy.units.Quantity`</span>
<span class="sd">        The differential longitude and latitude.</span>
<span class="sd">    d_distance : `~astropy.units.Quantity`</span>
<span class="sd">        The differential distance.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">SphericalRepresentation</span>
    <span class="n">_unit_differential</span> <span class="o">=</span> <span class="n">UnitSphericalDifferential</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_lon</span><span class="p">,</span> <span class="n">d_lat</span><span class="p">,</span> <span class="n">d_distance</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SphericalDifferential</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">d_lat</span><span class="p">,</span> <span class="n">d_distance</span><span class="p">,</span>
                                                    <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_lon</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lat</span><span class="o">.</span><span class="n">unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s1">&#39;d_lon and d_lat should have equivalent units.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="SphericalDifferential.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalDifferential.html#astropy.coordinates.SphericalDifferential.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># All spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though CosLat needs base for the latitude.</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">RadialDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">SphericalCosLatDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lon_coslat</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalCosLatDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lon_coslat</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">PhysicsSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lon</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SphericalDifferential</span><span class="p">,</span>
                         <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="SphericalDifferential.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalDifferential.html#astropy.coordinates.SphericalDifferential.from_representation">[docs]</a>    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Other spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though CosLat needs base for the latitude.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">SphericalCosLatDifferential</span><span class="p">):</span>
            <span class="n">d_lon</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_get_d_lon</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">PhysicsSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_phi</span><span class="p">,</span> <span class="o">-</span><span class="n">representation</span><span class="o">.</span><span class="n">d_theta</span><span class="p">,</span>
                       <span class="n">representation</span><span class="o">.</span><span class="n">d_r</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SphericalDifferential</span><span class="p">,</span>
                     <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_representation</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="BaseSphericalCosLatDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseSphericalCosLatDifferential.html#astropy.coordinates.BaseSphericalCosLatDifferential">[docs]</a><span class="k">class</span> <span class="nc">BaseSphericalCosLatDifferential</span><span class="p">(</span><span class="n">BaseDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differtials from points on a spherical base representation.</span>

<span class="sd">    With cos(lat) assumed to be included in the longitude differential.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_base_vectors</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get unit vectors and scale factors from (unit)spherical base.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : instance of ``self.base_representation``</span>
<span class="sd">            The points for which the unit vectors and scale factors should be</span>
<span class="sd">            retrieved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unit_vectors : dict of `CartesianRepresentation`</span>
<span class="sd">            In the directions of the coordinates of base.</span>
<span class="sd">        scale_factors : dict of `~astropy.units.Quantity`</span>
<span class="sd">            Scale factors for each of the coordinates.  The scale factor for</span>
<span class="sd">            longitude does not include the cos(lat) factor.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError : if the base is not of the correct type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">unit_vectors</span><span class="p">(),</span> <span class="n">base</span><span class="o">.</span><span class="n">scale_factors</span><span class="p">(</span><span class="n">omit_coslat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_d_lon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert longitude differential with cos(lat) to one without.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : instance of ``cls.base_representation``</span>
<span class="sd">            The base from which the latitude will be taken.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lon_coslat</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_d_lon_coslat</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d_lon</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert longitude differential d_lon to d_lon_coslat.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d_lon : `~astropy.units.Quantity`</span>
<span class="sd">            Value of the longitude differential without ``cos(lat)``.</span>
<span class="sd">        base : instance of ``cls.base_representation``</span>
<span class="sd">            The base from which the latitude will be taken.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d_lon</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine two differentials, or a differential with a representation.</span>

<span class="sd">        If ``other`` is of the same differential type as ``self``, the</span>
<span class="sd">        components will simply be combined.  If both are different parts of</span>
<span class="sd">        a `~astropy.coordinates.SphericalDifferential` (e.g., a</span>
<span class="sd">        `~astropy.coordinates.UnitSphericalDifferential` and a</span>
<span class="sd">        `~astropy.coordinates.RadialDifferential`), they will combined</span>
<span class="sd">        appropriately.</span>

<span class="sd">        If ``other`` is a representation, it will be used as a base for which</span>
<span class="sd">        to evaluate the differential, and the result is a new representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op : `~operator` callable</span>
<span class="sd">            Operator to apply (e.g., `~operator.add`, `~operator.sub`, etc.</span>
<span class="sd">        other : `~astropy.coordinates.BaseRepresentation` instance</span>
<span class="sd">            The other differential or representation.</span>
<span class="sd">        reverse : bool</span>
<span class="sd">            Whether the operands should be reversed (e.g., as we got here via</span>
<span class="sd">            ``self.__rsub__`` because ``self`` is a subclass of ``other``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseSphericalCosLatDifferential</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="ow">or</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">RadialDifferential</span><span class="p">)):</span>
            <span class="n">all_components</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span> <span class="k">else</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">result_args</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">all_components</span><span class="p">}</span>
            <span class="k">return</span> <span class="n">SphericalCosLatDifferential</span><span class="p">(</span><span class="o">**</span><span class="n">result_args</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BaseSphericalCosLatDifferential</span><span class="p">,</span>
                     <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span></div>


<div class="viewcode-block" id="UnitSphericalCosLatDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalCosLatDifferential.html#astropy.coordinates.UnitSphericalCosLatDifferential">[docs]</a><span class="k">class</span> <span class="nc">UnitSphericalCosLatDifferential</span><span class="p">(</span><span class="n">BaseSphericalCosLatDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differential(s) of points on a unit sphere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_lon_coslat, d_lat : `~astropy.units.Quantity`</span>
<span class="sd">        The longitude and latitude of the differentials.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">UnitSphericalRepresentation</span>
    <span class="n">attr_classes</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;d_lon_coslat&#39;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">),</span>
                                <span class="p">(</span><span class="s1">&#39;d_lat&#39;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)])</span>

    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">_dimensional_differential</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SphericalCosLatDifferential</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">d_lat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UnitSphericalCosLatDifferential</span><span class="p">,</span>
              <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">d_lat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_lon_coslat</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lat</span><span class="o">.</span><span class="n">unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s1">&#39;d_lon_coslat and d_lat should have equivalent &#39;</span>
                               <span class="s1">&#39;units.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="UnitSphericalCosLatDifferential.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalCosLatDifferential.html#astropy.coordinates.UnitSphericalCosLatDifferential.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">SphericalRepresentation</span><span class="p">):</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">distance</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">PhysicsSphericalRepresentation</span><span class="p">):</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">UnitSphericalCosLatDifferential</span><span class="p">,</span>
                         <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

        <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">UnitSphericalRepresentation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scale</span> <span class="o">*</span> <span class="nb">super</span><span class="p">(</span><span class="n">UnitSphericalCosLatDifferential</span><span class="p">,</span>
                             <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="n">base</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitSphericalCosLatDifferential.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalCosLatDifferential.html#astropy.coordinates.UnitSphericalCosLatDifferential.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Only have enough information to represent other unit-spherical.</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lon</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">UnitSphericalCosLatDifferential</span><span class="p">,</span>
                     <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="UnitSphericalCosLatDifferential.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalCosLatDifferential.html#astropy.coordinates.UnitSphericalCosLatDifferential.from_representation">[docs]</a>    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># All spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though w/o CosLat needs base for the latitude.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">SphericalCosLatDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="p">(</span><span class="n">SphericalDifferential</span><span class="p">,</span>
                                         <span class="n">UnitSphericalDifferential</span><span class="p">)):</span>
            <span class="n">d_lon_coslat</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_get_d_lon_coslat</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">PhysicsSphericalDifferential</span><span class="p">):</span>
            <span class="n">d_lon_coslat</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_get_d_lon_coslat</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_phi</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="o">-</span><span class="n">representation</span><span class="o">.</span><span class="n">d_theta</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">UnitSphericalDifferential</span><span class="p">,</span>
                     <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_representation</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SphericalCosLatDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalCosLatDifferential.html#astropy.coordinates.SphericalCosLatDifferential">[docs]</a><span class="k">class</span> <span class="nc">SphericalCosLatDifferential</span><span class="p">(</span><span class="n">BaseSphericalCosLatDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differential(s) of points in 3D spherical coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_lon_coslat, d_lat : `~astropy.units.Quantity`</span>
<span class="sd">        The differential longitude (with cos(lat) included) and latitude.</span>
<span class="sd">    d_distance : `~astropy.units.Quantity`</span>
<span class="sd">        The differential distance.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">SphericalRepresentation</span>
    <span class="n">_unit_differential</span> <span class="o">=</span> <span class="n">UnitSphericalCosLatDifferential</span>
    <span class="n">attr_classes</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;d_lon_coslat&#39;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">),</span>
                                <span class="p">(</span><span class="s1">&#39;d_lat&#39;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">),</span>
                                <span class="p">(</span><span class="s1">&#39;d_distance&#39;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">d_lat</span><span class="p">,</span> <span class="n">d_distance</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SphericalCosLatDifferential</span><span class="p">,</span>
              <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">d_lat</span><span class="p">,</span> <span class="n">d_distance</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_lon_coslat</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lat</span><span class="o">.</span><span class="n">unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s1">&#39;d_lon_coslat and d_lat should have equivalent &#39;</span>
                               <span class="s1">&#39;units.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="SphericalCosLatDifferential.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalCosLatDifferential.html#astropy.coordinates.SphericalCosLatDifferential.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># All spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though some need base for the latitude to remove cos(lat).</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalCosLatDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">RadialDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">SphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lon</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lon</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">PhysicsSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lon</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SphericalCosLatDifferential</span><span class="p">,</span>
                     <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="SphericalCosLatDifferential.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalCosLatDifferential.html#astropy.coordinates.SphericalCosLatDifferential.from_representation">[docs]</a>    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Other spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though we need base for the latitude to remove coslat.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">SphericalDifferential</span><span class="p">):</span>
            <span class="n">d_lon_coslat</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_get_d_lon_coslat</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span>
                       <span class="n">representation</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">PhysicsSphericalDifferential</span><span class="p">):</span>
            <span class="n">d_lon_coslat</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_get_d_lon_coslat</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_phi</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="o">-</span><span class="n">representation</span><span class="o">.</span><span class="n">d_theta</span><span class="p">,</span>
                       <span class="n">representation</span><span class="o">.</span><span class="n">d_r</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SphericalCosLatDifferential</span><span class="p">,</span>
                     <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_representation</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RadialDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialDifferential.html#astropy.coordinates.RadialDifferential">[docs]</a><span class="k">class</span> <span class="nc">RadialDifferential</span><span class="p">(</span><span class="n">BaseDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differential(s) of radial distances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_distance : `~astropy.units.Quantity`</span>
<span class="sd">        The differential distance.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">RadialRepresentation</span>

<div class="viewcode-block" id="RadialDifferential.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialDifferential.html#astropy.coordinates.RadialDifferential.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span> <span class="o">*</span> <span class="n">base</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span>
            <span class="n">UnitSphericalRepresentation</span><span class="p">)</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="RadialDifferential.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialDifferential.html#astropy.coordinates.RadialDifferential.from_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">UnitSphericalRepresentation</span><span class="p">)),</span>
                   <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="RadialDifferential.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialDifferential.html#astropy.coordinates.RadialDifferential.from_representation">[docs]</a>    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="p">(</span><span class="n">SphericalDifferential</span><span class="p">,</span>
                                       <span class="n">SphericalCosLatDifferential</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">PhysicsSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">RadialDifferential</span><span class="p">,</span>
                         <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_representation</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_representation</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">distance</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">BaseSphericalDifferential</span><span class="p">,</span>
                                <span class="n">BaseSphericalCosLatDifferential</span><span class="p">)):</span>
            <span class="n">all_components</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span> <span class="k">else</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">result_args</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">all_components</span><span class="p">}</span>
            <span class="k">return</span> <span class="n">SphericalDifferential</span><span class="p">(</span><span class="o">**</span><span class="n">result_args</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">RadialDifferential</span><span class="p">,</span>
                         <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span></div>


<div class="viewcode-block" id="PhysicsSphericalDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalDifferential.html#astropy.coordinates.PhysicsSphericalDifferential">[docs]</a><span class="k">class</span> <span class="nc">PhysicsSphericalDifferential</span><span class="p">(</span><span class="n">BaseDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differential(s) of 3D spherical coordinates using physics convention.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_phi, d_theta : `~astropy.units.Quantity`</span>
<span class="sd">        The differential azimuth and inclination.</span>
<span class="sd">    d_r : `~astropy.units.Quantity`</span>
<span class="sd">        The differential radial distance.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">PhysicsSphericalRepresentation</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_phi</span><span class="p">,</span> <span class="n">d_theta</span><span class="p">,</span> <span class="n">d_r</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PhysicsSphericalDifferential</span><span class="p">,</span>
              <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">d_phi</span><span class="p">,</span> <span class="n">d_theta</span><span class="p">,</span> <span class="n">d_r</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_phi</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_theta</span><span class="o">.</span><span class="n">unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s1">&#39;d_phi and d_theta should have equivalent &#39;</span>
                               <span class="s1">&#39;units.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="PhysicsSphericalDifferential.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalDifferential.html#astropy.coordinates.PhysicsSphericalDifferential.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># All spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though CosLat needs base for the latitude. For those, explicitly</span>
        <span class="c1"># do the equivalent of self._d_lon_coslat in SphericalDifferential.</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">SphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_phi</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_r</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_phi</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d_theta</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">SphericalCosLatDifferential</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="n">d_lon_coslat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_phi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_r</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalCosLatDifferential</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="n">d_lon_coslat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_phi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d_theta</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">RadialDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_r</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">PhysicsSphericalDifferential</span><span class="p">,</span>
                     <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="PhysicsSphericalDifferential.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalDifferential.html#astropy.coordinates.PhysicsSphericalDifferential.from_representation">[docs]</a>    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Other spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though we need base for the latitude to remove coslat. For that case,</span>
        <span class="c1"># do the equivalent of cls._d_lon in SphericalDifferential.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">SphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lon</span><span class="p">,</span> <span class="o">-</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span>
                       <span class="n">representation</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">SphericalCosLatDifferential</span><span class="p">):</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="n">d_phi</span> <span class="o">=</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_lon_coslat</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">d_phi</span><span class="p">,</span> <span class="o">-</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">PhysicsSphericalDifferential</span><span class="p">,</span>
                     <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_representation</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CylindricalDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.CylindricalDifferential.html#astropy.coordinates.CylindricalDifferential">[docs]</a><span class="k">class</span> <span class="nc">CylindricalDifferential</span><span class="p">(</span><span class="n">BaseDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differential(s) of points in cylindrical coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_rho : `~astropy.units.Quantity`</span>
<span class="sd">        The differential cylindrical radius.</span>
<span class="sd">    d_phi : `~astropy.units.Quantity`</span>
<span class="sd">        The differential azimuth.</span>
<span class="sd">    d_z : `~astropy.units.Quantity`</span>
<span class="sd">        The differential height.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied rather than referenced.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">CylindricalRepresentation</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_rho</span><span class="p">,</span> <span class="n">d_phi</span><span class="p">,</span> <span class="n">d_z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CylindricalDifferential</span><span class="p">,</span>
              <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">d_rho</span><span class="p">,</span> <span class="n">d_phi</span><span class="p">,</span> <span class="n">d_z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_rho</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_z</span><span class="o">.</span><span class="n">unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;d_rho and d_z should have equivalent units.&quot;</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011-2016, The Astropy Developers.<br/>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.5.6. &nbsp;
    Last built 05 Jul 2017. <br/>
  </p>
</footer>
  </body>
</html>