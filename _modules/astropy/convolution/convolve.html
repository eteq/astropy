<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>astropy.convolution.convolve &#8212; Astropy v3.0.dev19489</title>
    
    <link rel="stylesheet" href="../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '3.0.dev19489',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/astropy_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>
<script type="text/javascript" src="../../../_static/copybutton.js"></script>


  </head>
  <body role="document">
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">Astropy v3.0.dev19489</a>
	 &#187;
      </li>
      <li><a href="../../index.html" >Module code</a> &#187;</li>
      <li><a href="../../astropy.html" accesskey="U">astropy</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for astropy.convolution.convolve</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>

<span class="kn">from</span> <span class="nn">.core</span> <span class="k">import</span> <span class="n">Kernel</span><span class="p">,</span> <span class="n">Kernel1D</span><span class="p">,</span> <span class="n">Kernel2D</span><span class="p">,</span> <span class="n">MAX_NORMALIZATION</span>
<span class="kn">from</span> <span class="nn">..utils.exceptions</span> <span class="k">import</span> <span class="n">AstropyUserWarning</span>
<span class="kn">from</span> <span class="nn">..utils.console</span> <span class="k">import</span> <span class="n">human_file_size</span>
<span class="kn">from</span> <span class="nn">..utils.decorators</span> <span class="k">import</span> <span class="n">deprecated_renamed_argument</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
<span class="kn">from</span> <span class="nn">..nddata</span> <span class="k">import</span> <span class="n">support_nddata</span>
<span class="kn">from</span> <span class="nn">..modeling.core</span> <span class="k">import</span> <span class="n">_make_arithmetic_operator</span><span class="p">,</span> <span class="n">BINARY_OPERATORS</span>
<span class="kn">from</span> <span class="nn">..modeling.core</span> <span class="k">import</span> <span class="n">_CompoundModelMeta</span>

<span class="kn">from</span> <span class="nn">..extern.six.moves</span> <span class="k">import</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">zip</span>


<span class="c1"># Disabling all doctests in this module until a better way of handling warnings</span>
<span class="c1"># in doctests can be determined</span>
<span class="n">__doctest_skip__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">]</span>

<span class="n">BOUNDARY_OPTIONS</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="s1">&#39;wrap&#39;</span><span class="p">,</span> <span class="s1">&#39;extend&#39;</span><span class="p">]</span>


<span class="nd">@support_nddata</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="convolve"><a class="viewcode-back" href="../../../api/astropy.convolution.convolve.html#astropy.convolution.convolve">[docs]</a><span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
             <span class="n">nan_treatment</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> <span class="n">normalize_kernel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">preserve_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalization_zero_tol</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">8</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Convolve an array with a kernel.</span>

<span class="sd">    This routine differs from `scipy.ndimage.convolve` because</span>
<span class="sd">    it includes a special treatment for ``NaN`` values. Rather than</span>
<span class="sd">    including ``NaN`` values in the array in the convolution calculation, which</span>
<span class="sd">    causes large ``NaN`` holes in the convolved array, ``NaN`` values are</span>
<span class="sd">    replaced with interpolated values using the kernel as an interpolation</span>
<span class="sd">    function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : `numpy.ndarray` or `~astropy.nddata.NDData`</span>
<span class="sd">        The array to convolve. This should be a 1, 2, or 3-dimensional array</span>
<span class="sd">        or a list or a set of nested lists representing a 1, 2, or</span>
<span class="sd">        3-dimensional array.  If an `~astropy.nddata.NDData`, the ``mask`` of</span>
<span class="sd">        the `~astropy.nddata.NDData` will be used as the ``mask`` argument.</span>
<span class="sd">    kernel : `numpy.ndarray` or `~astropy.convolution.Kernel`</span>
<span class="sd">        The convolution kernel. The number of dimensions should match those for</span>
<span class="sd">        the array, and the dimensions should be odd in all directions.  If a</span>
<span class="sd">        masked array, the masked values will be replaced by ``fill_value``.</span>
<span class="sd">    boundary : str, optional</span>
<span class="sd">        A flag indicating how to handle boundaries:</span>
<span class="sd">            * `None`</span>
<span class="sd">                Set the ``result`` values to zero where the kernel</span>
<span class="sd">                extends beyond the edge of the array (default).</span>
<span class="sd">            * &#39;fill&#39;</span>
<span class="sd">                Set values outside the array boundary to ``fill_value``.</span>
<span class="sd">            * &#39;wrap&#39;</span>
<span class="sd">                Periodic boundary that wrap to the other side of ``array``.</span>
<span class="sd">            * &#39;extend&#39;</span>
<span class="sd">                Set values outside the array to the nearest ``array``</span>
<span class="sd">                value.</span>
<span class="sd">    fill_value : float, optional</span>
<span class="sd">        The value to use outside the array when using ``boundary=&#39;fill&#39;``</span>
<span class="sd">    normalize_kernel : bool, optional</span>
<span class="sd">        Whether to normalize the kernel to have a sum of one prior to</span>
<span class="sd">        convolving</span>
<span class="sd">    nan_treatment : &#39;interpolate&#39;, &#39;fill&#39;</span>
<span class="sd">        interpolate will result in renormalization of the kernel at each</span>
<span class="sd">        position ignoring (pixels that are NaN in the image) in both the image</span>
<span class="sd">        and the kernel.</span>
<span class="sd">        &#39;fill&#39; will replace the NaN pixels with a fixed numerical value (default</span>
<span class="sd">        zero, see ``fill_value``) prior to convolution</span>
<span class="sd">        Note that if the kernel has a sum equal to zero, NaN interpolation</span>
<span class="sd">        is not possible and will raise an exception</span>
<span class="sd">    preserve_nan : bool</span>
<span class="sd">        After performing convolution, should pixels that were originally NaN</span>
<span class="sd">        again become NaN?</span>
<span class="sd">    mask : `None` or `numpy.ndarray`</span>
<span class="sd">        A &quot;mask&quot; array.  Shape must match ``array``, and anything that is masked</span>
<span class="sd">        (i.e., not 0/`False`) will be set to NaN for the convolution.  If</span>
<span class="sd">        `None`, no masking will be performed unless ``array`` is a masked array.</span>
<span class="sd">        If ``mask`` is not `None` *and* ``array`` is a masked array, a pixel is</span>
<span class="sd">        masked of it is masked in either ``mask`` *or* ``array.mask``.</span>
<span class="sd">    normalization_zero_tol: float, optional</span>
<span class="sd">        The absolute tolerance on whether the kernel is different than zero.</span>
<span class="sd">        If the kernel sums to zero to within this precision, it cannot be</span>
<span class="sd">        normalized. Default is &quot;1e-8&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : `numpy.ndarray`</span>
<span class="sd">        An array with the same dimensions and as the input array,</span>
<span class="sd">        convolved with kernel.  The data type depends on the input</span>
<span class="sd">        array type.  If array is a floating point type, then the</span>
<span class="sd">        return array keeps the same data type, otherwise the type</span>
<span class="sd">        is ``numpy.float``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For masked arrays, masked values are treated as NaNs.  The convolution</span>
<span class="sd">    is always done at ``numpy.float`` precision.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">.boundary_none</span> <span class="k">import</span> <span class="p">(</span><span class="n">convolve1d_boundary_none</span><span class="p">,</span>
                                <span class="n">convolve2d_boundary_none</span><span class="p">,</span>
                                <span class="n">convolve3d_boundary_none</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">.boundary_extend</span> <span class="k">import</span> <span class="p">(</span><span class="n">convolve1d_boundary_extend</span><span class="p">,</span>
                                  <span class="n">convolve2d_boundary_extend</span><span class="p">,</span>
                                  <span class="n">convolve3d_boundary_extend</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">.boundary_fill</span> <span class="k">import</span> <span class="p">(</span><span class="n">convolve1d_boundary_fill</span><span class="p">,</span>
                                <span class="n">convolve2d_boundary_fill</span><span class="p">,</span>
                                <span class="n">convolve3d_boundary_fill</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">.boundary_wrap</span> <span class="k">import</span> <span class="p">(</span><span class="n">convolve1d_boundary_wrap</span><span class="p">,</span>
                                <span class="n">convolve2d_boundary_wrap</span><span class="p">,</span>
                                <span class="n">convolve3d_boundary_wrap</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">boundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">BOUNDARY_OPTIONS</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid boundary option: must be one of </span><span class="si">{0}</span><span class="s2">&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">BOUNDARY_OPTIONS</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">nan_treatment</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nan_treatment must be one of &#39;interpolate&#39;,&#39;fill&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># The cython routines all need float type inputs (so, a particular</span>
    <span class="c1"># bit size, endianness, etc.).  So we have to convert, which also</span>
    <span class="c1"># has the effect of making copies so we don&#39;t modify the inputs.</span>
    <span class="c1"># After this, the variables we work with will be array_internal, and</span>
    <span class="c1"># kernel_internal.  However -- we do want to keep track of what type</span>
    <span class="c1"># the input array was so we can cast the result to that at the end</span>
    <span class="c1"># if it&#39;s a floating point type.  Don&#39;t bother with this for lists --</span>
    <span class="c1"># just always push those as np.float.</span>
    <span class="c1"># It is always necessary to make a copy of kernel (since it is modified),</span>
    <span class="c1"># but, if we just so happen to be lucky enough to have the input array</span>
    <span class="c1"># have exactly the desired type, we just alias to array_internal</span>

    <span class="c1"># Check if kernel is kernel instance</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
        <span class="c1"># Check if array is also kernel instance, if so convolve and</span>
        <span class="c1"># return new kernel instance</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">Kernel1D</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">Kernel1D</span><span class="p">):</span>
                <span class="n">new_array</span> <span class="o">=</span> <span class="n">convolve1d_boundary_fill</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                                                     <span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">new_kernel</span> <span class="o">=</span> <span class="n">Kernel1D</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="n">new_array</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">Kernel2D</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">Kernel2D</span><span class="p">):</span>
                <span class="n">new_array</span> <span class="o">=</span> <span class="n">convolve2d_boundary_fill</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                                                     <span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">new_kernel</span> <span class="o">=</span> <span class="n">Kernel2D</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="n">new_array</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Can&#39;t convolve 1D and 2D kernel.&quot;</span><span class="p">)</span>
            <span class="n">new_kernel</span><span class="o">.</span><span class="n">_separable</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">_separable</span> <span class="ow">and</span> <span class="n">array</span><span class="o">.</span><span class="n">_separable</span>
            <span class="n">new_kernel</span><span class="o">.</span><span class="n">_is_bool</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">new_kernel</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">array</span>

    <span class="c1"># Check that the arguments are lists or Numpy arrays</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">array_internal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">array_dtype</span> <span class="o">=</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Note this won&#39;t copy if it doesn&#39;t have to -- which is okay</span>
        <span class="c1"># because none of what follows modifies array_internal.  However,</span>
        <span class="c1"># only numpy &gt; 1.7 has support for no-copy astype, so we use</span>
        <span class="c1"># a try/except because astropy supports 1.5 and 1.6</span>
        <span class="n">array_dtype</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">array_internal</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">array_internal</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;array should be a list or a Numpy array&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">kernel_internal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Note this always makes a copy, since we will be modifying it</span>
        <span class="n">kernel_internal</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;kernel should be a list or a Numpy array&quot;</span><span class="p">)</span>

    <span class="c1"># Check that the number of dimensions is compatible</span>
    <span class="k">if</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">kernel_internal</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;array and kernel have differing number of &#39;</span>
                        <span class="s1">&#39;dimensions.&#39;</span><span class="p">)</span>

    <span class="c1"># anything that&#39;s masked must be turned into NaNs for the interpolation.</span>
    <span class="c1"># This requires copying the array_internal</span>
    <span class="n">array_internal_copied</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="n">array_internal</span> <span class="o">=</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">array_internal_copied</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">array_internal_copied</span><span class="p">:</span>
            <span class="n">array_internal</span> <span class="o">=</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">array_internal_copied</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># mask != 0 yields a bool mask for all ints/floats/bool</span>
        <span class="n">array_internal</span><span class="p">[</span><span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">kernel</span><span class="p">):</span>
        <span class="c1"># *kernel* doesn&#39;t support NaN interpolation, so instead we just fill it</span>
        <span class="n">kernel_internal</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="c1"># Mark the NaN values so we can replace them later if interpolate_nan is</span>
    <span class="c1"># not set</span>
    <span class="k">if</span> <span class="n">preserve_nan</span><span class="p">:</span>
        <span class="n">badvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array_internal</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nan_treatment</span> <span class="o">==</span> <span class="s1">&#39;fill&#39;</span><span class="p">:</span>
        <span class="n">initially_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array_internal</span><span class="p">)</span>
        <span class="n">array_internal</span><span class="p">[</span><span class="n">initially_nan</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>

    <span class="c1"># Because the Cython routines have to normalize the kernel on the fly, we</span>
    <span class="c1"># explicitly normalize the kernel here, and then scale the image at the</span>
    <span class="c1"># end if normalization was not requested.</span>
    <span class="n">kernel_sum</span> <span class="o">=</span> <span class="n">kernel_internal</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">kernel_sums_to_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">kernel_sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">normalization_zero_tol</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">kernel_sum</span> <span class="o">&lt;</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">MAX_NORMALIZATION</span> <span class="ow">or</span> <span class="n">kernel_sums_to_zero</span><span class="p">)</span> <span class="ow">and</span> <span class="n">normalize_kernel</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The kernel can&#39;t be normalized, because its sum is &quot;</span>
                        <span class="s2">&quot;close to zero. The sum of the given kernel is &lt; </span><span class="si">{0}</span><span class="s2">&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">MAX_NORMALIZATION</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">kernel_sums_to_zero</span><span class="p">:</span>
        <span class="n">kernel_internal</span> <span class="o">/=</span> <span class="n">kernel_sum</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kernel_internal</span> <span class="o">=</span> <span class="n">kernel</span>

    <span class="n">renormalize_by_kernel</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">kernel_sums_to_zero</span>

    <span class="k">if</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;cannot convolve 0-dimensional arrays&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;extend&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve1d_boundary_extend</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                                <span class="n">kernel_internal</span><span class="p">,</span>
                                                <span class="n">renormalize_by_kernel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;fill&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve1d_boundary_fill</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">,</span>
                                              <span class="nb">float</span><span class="p">(</span><span class="n">fill_value</span><span class="p">),</span>
                                              <span class="n">renormalize_by_kernel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve1d_boundary_wrap</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">,</span>
                                              <span class="n">renormalize_by_kernel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve1d_boundary_none</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">,</span>
                                              <span class="n">renormalize_by_kernel</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;extend&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve2d_boundary_extend</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                                <span class="n">kernel_internal</span><span class="p">,</span>
                                                <span class="n">renormalize_by_kernel</span><span class="p">,</span>
                                               <span class="p">)</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;fill&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve2d_boundary_fill</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">,</span>
                                              <span class="nb">float</span><span class="p">(</span><span class="n">fill_value</span><span class="p">),</span>
                                              <span class="n">renormalize_by_kernel</span><span class="p">,</span>
                                             <span class="p">)</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve2d_boundary_wrap</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">,</span>
                                              <span class="n">renormalize_by_kernel</span><span class="p">,</span>
                                             <span class="p">)</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve2d_boundary_none</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">,</span>
                                              <span class="n">renormalize_by_kernel</span><span class="p">,</span>
                                             <span class="p">)</span>
    <span class="k">elif</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;extend&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve3d_boundary_extend</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                                <span class="n">kernel_internal</span><span class="p">,</span>
                                                <span class="n">renormalize_by_kernel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;fill&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve3d_boundary_fill</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">,</span>
                                              <span class="nb">float</span><span class="p">(</span><span class="n">fill_value</span><span class="p">),</span>
                                              <span class="n">renormalize_by_kernel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve3d_boundary_wrap</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">,</span>
                                              <span class="n">renormalize_by_kernel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve3d_boundary_none</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">,</span>
                                              <span class="n">renormalize_by_kernel</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;convolve only supports 1, 2, and 3-dimensional &#39;</span>
                                  <span class="s1">&#39;arrays at this time&#39;</span><span class="p">)</span>

    <span class="c1"># If normalization was not requested, we need to scale the array (since</span>
    <span class="c1"># the kernel is effectively normalized within the cython functions)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">normalize_kernel</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kernel_sums_to_zero</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">*=</span> <span class="n">kernel_sum</span>

    <span class="k">if</span> <span class="n">preserve_nan</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="n">badvals</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="n">nan_treatment</span> <span class="o">==</span> <span class="s1">&#39;fill&#39;</span><span class="p">:</span>
        <span class="n">array_internal</span><span class="p">[</span><span class="n">initially_nan</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Try to preserve the input type if it&#39;s a floating point type</span>
    <span class="k">if</span> <span class="n">array_dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
        <span class="c1"># Avoid making another copy if possible</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">array_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">array_dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span></div>


<span class="nd">@deprecated_renamed_argument</span><span class="p">(</span><span class="s1">&#39;interpolate_nan&#39;</span><span class="p">,</span> <span class="s1">&#39;nan_treatment&#39;</span><span class="p">,</span> <span class="s1">&#39;v2.0.0&#39;</span><span class="p">)</span>
<span class="nd">@support_nddata</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="convolve_fft"><a class="viewcode-back" href="../../../api/astropy.convolution.convolve_fft.html#astropy.convolution.convolve_fft">[docs]</a><span class="k">def</span> <span class="nf">convolve_fft</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                 <span class="n">nan_treatment</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> <span class="n">normalize_kernel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">normalization_zero_tol</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span>
                 <span class="n">preserve_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_fft</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">fft_pad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">psf_pad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">min_wt</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">allow_huge</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">fftn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">,</span> <span class="n">ifftn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">,</span>
                 <span class="n">complex_dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve an ndarray with an nd-kernel.  Returns a convolved image with</span>
<span class="sd">    ``shape = array.shape``.  Assumes kernel is centered.</span>

<span class="sd">    `convolve_fft` is very similar to `convolve` in that it replaces ``NaN``</span>
<span class="sd">    values in the original image with interpolated values using the kernel as</span>
<span class="sd">    an interpolation function.  However, it also includes many additional</span>
<span class="sd">    options specific to the implementation.</span>

<span class="sd">    `convolve_fft` differs from `scipy.signal.fftconvolve` in a few ways:</span>

<span class="sd">    * It can treat ``NaN`` values as zeros or interpolate over them.</span>
<span class="sd">    * ``inf`` values are treated as ``NaN``</span>
<span class="sd">    * (optionally) It pads to the nearest 2^n size to improve FFT speed.</span>
<span class="sd">    * Its only valid ``mode`` is &#39;same&#39; (i.e., the same shape array is returned)</span>
<span class="sd">    * It lets you use your own fft, e.g.,</span>
<span class="sd">      `pyFFTW &lt;http://pypi.python.org/pypi/pyFFTW&gt;`_ or</span>
<span class="sd">      `pyFFTW3 &lt;http://pypi.python.org/pypi/PyFFTW3/0.2.1&gt;`_ , which can lead to</span>
<span class="sd">      performance improvements, depending on your system configuration.  pyFFTW3</span>
<span class="sd">      is threaded, and therefore may yield significant performance benefits on</span>
<span class="sd">      multi-core machines at the cost of greater memory requirements.  Specify</span>
<span class="sd">      the ``fftn`` and ``ifftn`` keywords to override the default, which is</span>
<span class="sd">      `numpy.fft.fft` and `numpy.fft.ifft`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : `numpy.ndarray`</span>
<span class="sd">        Array to be convolved with ``kernel``.  It can be of any</span>
<span class="sd">        dimensionality, though only 1, 2, and 3d arrays have been tested.</span>
<span class="sd">    kernel : `numpy.ndarray` or `astropy.convolution.Kernel`</span>
<span class="sd">        The convolution kernel. The number of dimensions should match those</span>
<span class="sd">        for the array.  The dimensions *do not* have to be odd in all directions,</span>
<span class="sd">        unlike in the non-fft `convolve` function.  The kernel will be</span>
<span class="sd">        normalized if ``normalize_kernel`` is set.  It is assumed to be centered</span>
<span class="sd">        (i.e., shifts may result if your kernel is asymmetric)</span>
<span class="sd">    boundary : {&#39;fill&#39;, &#39;wrap&#39;}, optional</span>
<span class="sd">        A flag indicating how to handle boundaries:</span>

<span class="sd">            * &#39;fill&#39;: set values outside the array boundary to fill_value</span>
<span class="sd">              (default)</span>
<span class="sd">            * &#39;wrap&#39;: periodic boundary</span>

<span class="sd">        The `None` and &#39;extend&#39; parameters are not supported for FFT-based</span>
<span class="sd">        convolution</span>
<span class="sd">    fill_value : float, optional</span>
<span class="sd">        The value to use outside the array when using boundary=&#39;fill&#39;</span>
<span class="sd">    nan_treatment : &#39;interpolate&#39;, &#39;fill&#39;</span>
<span class="sd">        ``interpolate`` will result in renormalization of the kernel at each</span>
<span class="sd">        position ignoring (pixels that are NaN in the image) in both the image</span>
<span class="sd">        and the kernel.  ``fill`` will replace the NaN pixels with a fixed</span>
<span class="sd">        numerical value (default zero, see ``fill_value``) prior to</span>
<span class="sd">        convolution.  Note that if the kernel has a sum equal to zero, NaN</span>
<span class="sd">        interpolation is not possible and will raise an exception.</span>
<span class="sd">    normalize_kernel : function or boolean, optional</span>
<span class="sd">        If specified, this is the function to divide kernel by to normalize it.</span>
<span class="sd">        e.g., ``normalize_kernel=np.sum`` means that kernel will be modified to be:</span>
<span class="sd">        ``kernel = kernel / np.sum(kernel)``.  If True, defaults to</span>
<span class="sd">        ``normalize_kernel = np.sum``.</span>
<span class="sd">    normalization_zero_tol: float, optional</span>
<span class="sd">        The absolute tolerance on whether the kernel is different than zero.</span>
<span class="sd">        If the kernel sums to zero to within this precision, it cannot be</span>
<span class="sd">        normalized. Default is &quot;1e-8&quot;.</span>
<span class="sd">    preserve_nan : bool</span>
<span class="sd">        After performing convolution, should pixels that were originally NaN</span>
<span class="sd">        again become NaN?</span>
<span class="sd">    mask : `None` or `numpy.ndarray`</span>
<span class="sd">        A &quot;mask&quot; array.  Shape must match ``array``, and anything that is masked</span>
<span class="sd">        (i.e., not 0/`False`) will be set to NaN for the convolution.  If</span>
<span class="sd">        `None`, no masking will be performed unless ``array`` is a masked array.</span>
<span class="sd">        If ``mask`` is not `None` *and* ``array`` is a masked array, a pixel is</span>
<span class="sd">        masked of it is masked in either ``mask`` *or* ``array.mask``.</span>


<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    min_wt : float, optional</span>
<span class="sd">        If ignoring ``NaN`` / zeros, force all grid points with a weight less than</span>
<span class="sd">        this value to ``NaN`` (the weight of a grid point with *no* ignored</span>
<span class="sd">        neighbors is 1.0).</span>
<span class="sd">        If ``min_wt`` is zero, then all zero-weight points will be set to zero</span>
<span class="sd">        instead of ``NaN`` (which they would be otherwise, because 1/0 = nan).</span>
<span class="sd">        See the examples below</span>
<span class="sd">    fft_pad : bool, optional</span>
<span class="sd">        Default on.  Zero-pad image to the nearest 2^n.  With</span>
<span class="sd">        ``boundary=&#39;wrap&#39;``, this will be disabled.</span>
<span class="sd">    psf_pad : bool, optional</span>
<span class="sd">        Zero-pad image to be at least the sum of the image sizes to avoid</span>
<span class="sd">        edge-wrapping when smoothing.  This is enabled by default with</span>
<span class="sd">        ``boundary=&#39;fill&#39;``, but it can be overridden with a boolean option.</span>
<span class="sd">        ``boundary=&#39;wrap&#39;`` and ``psf_pad=True`` are not compatible.</span>
<span class="sd">    crop : bool, optional</span>
<span class="sd">        Default on.  Return an image of the size of the larger of the input</span>
<span class="sd">        image and the kernel.</span>
<span class="sd">        If the image and kernel are asymmetric in opposite directions, will</span>
<span class="sd">        return the largest image in both directions.</span>
<span class="sd">        For example, if an input image has shape [100,3] but a kernel with shape</span>
<span class="sd">        [6,6] is used, the output will be [100,6].</span>
<span class="sd">    return_fft : bool, optional</span>
<span class="sd">        Return the ``fft(image)*fft(kernel)`` instead of the convolution (which is</span>
<span class="sd">        ``ifft(fft(image)*fft(kernel))``).  Useful for making PSDs.</span>
<span class="sd">    fftn, ifftn : functions, optional</span>
<span class="sd">        The fft and inverse fft functions.  Can be overridden to use your own</span>
<span class="sd">        ffts, e.g. an fftw3 wrapper or scipy&#39;s fftn,</span>
<span class="sd">        ``fft=scipy.fftpack.fftn``</span>
<span class="sd">    complex_dtype : numpy.complex, optional</span>
<span class="sd">        Which complex dtype to use.  `numpy` has a range of options, from 64 to</span>
<span class="sd">        256.</span>
<span class="sd">    quiet : bool, optional</span>
<span class="sd">        Silence warning message about NaN interpolation</span>
<span class="sd">    allow_huge : bool, optional</span>
<span class="sd">        Allow huge arrays in the FFT?  If False, will raise an exception if the</span>
<span class="sd">        array or kernel size is &gt;1 GB</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError:</span>
<span class="sd">        If the array is bigger than 1 GB after padding, will raise this exception</span>
<span class="sd">        unless ``allow_huge`` is True</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    convolve:</span>
<span class="sd">        Convolve is a non-fft version of this code.  It is more memory</span>
<span class="sd">        efficient and for small kernels can be faster.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    default : ndarray</span>
<span class="sd">        ``array`` convolved with ``kernel``.  If ``return_fft`` is set, returns</span>
<span class="sd">        ``fft(array) * fft(kernel)``.  If crop is not set, returns the</span>
<span class="sd">        image, but with the fft-padded size instead of the input size</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">        With ``psf_pad=True`` and a large PSF, the resulting data can become</span>
<span class="sd">        very large and consume a lot of memory.  See Issue</span>
<span class="sd">        https://github.com/astropy/astropy/pull/4366 for further detail.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; convolve_fft([1, 0, 3], [1, 1, 1])</span>
<span class="sd">    array([ 1.,  4.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1])</span>
<span class="sd">    array([ 1.,  4.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, 0, 3], [0, 1, 0])</span>
<span class="sd">    array([ 1.,  0.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, 2, 3], [1])</span>
<span class="sd">    array([ 1.,  2.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [0, 1, 0], nan_treatment=&#39;interpolate&#39;)</span>
<span class="sd">    ...</span>
<span class="sd">    array([ 1.,  0.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [0, 1, 0], nan_treatment=&#39;interpolate&#39;,</span>
<span class="sd">    ...              min_wt=1e-8)</span>
<span class="sd">    array([ 1.,  nan,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1], nan_treatment=&#39;interpolate&#39;)</span>
<span class="sd">    array([ 1.,  4.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1], nan_treatment=&#39;interpolate&#39;,</span>
<span class="sd">    ...               normalize_kernel=True)</span>
<span class="sd">    array([ 1.,  2.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; import scipy.fftpack  # optional - requires scipy</span>
<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1], nan_treatment=&#39;interpolate&#39;,</span>
<span class="sd">    ...               normalize_kernel=True,</span>
<span class="sd">    ...               fftn=scipy.fftpack.fft, ifftn=scipy.fftpack.ifft)</span>
<span class="sd">    array([ 1.,  2.,  3.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Checking copied from convolve.py - however, since FFTs have real &amp;</span>
    <span class="c1"># complex components, we change the types.  Only the real part will be</span>
    <span class="c1"># returned! Note that this always makes a copy.</span>

    <span class="c1"># Check kernel is kernel instance</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t convolve two kernels with convolve_fft.  &quot;</span>
                            <span class="s2">&quot;Use convolve instead.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nan_treatment</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span> <span class="s1">&#39;fill&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nan_treatment must be one of &#39;interpolate&#39;,&#39;fill&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># Convert array dtype to complex</span>
    <span class="c1"># and ensure that list inputs become arrays</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>

    <span class="c1"># Check that the number of dimensions is compatible</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Image and kernel must have same number of &quot;</span>
                         <span class="s2">&quot;dimensions&quot;</span><span class="p">)</span>

    <span class="n">arrayshape</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">kernshape</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">array_size_B</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">*</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">complex_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">byte</span>
    <span class="k">if</span> <span class="n">array_size_B</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">GB</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_huge</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Size Error: Arrays will be </span><span class="si">{}</span><span class="s2">.  Use &quot;</span>
                         <span class="s2">&quot;allow_huge=True to override this exception.&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">human_file_size</span><span class="p">(</span><span class="n">array_size_B</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">byte</span><span class="p">))))</span>

    <span class="c1"># mask catching - masks must be turned into NaNs for use later in the image</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="n">mamask</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">array</span><span class="p">[</span><span class="n">mamask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">elif</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># copying here because we have to mask it below.  But no need to copy</span>
        <span class="c1"># if mask is None because we won&#39;t modify it.</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># mask != 0 yields a bool mask for all ints/floats/bool</span>
        <span class="n">array</span><span class="p">[</span><span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="c1"># the *kernel* doesn&#39;t support NaN interpolation, so instead we just fill it</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">kernel</span><span class="p">):</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># NaN and inf catching</span>
    <span class="n">nanmaskarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">array</span><span class="p">[</span><span class="n">nanmaskarray</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nanmaskkernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">kernel</span><span class="p">[</span><span class="n">nanmaskkernel</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">normalize_kernel</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">MAX_NORMALIZATION</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The kernel can&#39;t be normalized, because its sum is &quot;</span>
                            <span class="s2">&quot;close to zero. The sum of the given kernel is &lt; </span><span class="si">{0}</span><span class="s2">&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">MAX_NORMALIZATION</span><span class="p">))</span>
        <span class="n">kernel_scale</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">normalized_kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">/</span> <span class="n">kernel_scale</span>
        <span class="n">kernel_scale</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># if we want to normalize it, leave it normed!</span>
    <span class="k">elif</span> <span class="n">normalize_kernel</span><span class="p">:</span>
        <span class="c1"># try this.  If a function is not passed, the code will just crash... I</span>
        <span class="c1"># think type checking would be better but PEPs say otherwise...</span>
        <span class="n">kernel_scale</span> <span class="o">=</span> <span class="n">normalize_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
        <span class="n">normalized_kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">/</span> <span class="n">kernel_scale</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kernel_scale</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kernel_scale</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">normalization_zero_tol</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nan_treatment</span> <span class="o">==</span> <span class="s1">&#39;interpolate&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot interpolate NaNs with an unnormalizable kernel&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># the kernel&#39;s sum is near-zero, so it can&#39;t be scaled</span>
                <span class="n">kernel_scale</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">normalized_kernel</span> <span class="o">=</span> <span class="n">kernel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the kernel is normalizable; we&#39;ll temporarily normalize it</span>
            <span class="c1"># now and undo the normalization later.</span>
            <span class="n">normalized_kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">/</span> <span class="n">kernel_scale</span>

    <span class="k">if</span> <span class="n">boundary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The convolve_fft version of boundary=None is &quot;</span>
                      <span class="s2">&quot;equivalent to the convolve boundary=&#39;fill&#39;.  There is &quot;</span>
                      <span class="s2">&quot;no FFT equivalent to convolve&#39;s &quot;</span>
                      <span class="s2">&quot;zero-if-kernel-leaves-boundary&quot;</span><span class="p">,</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">psf_pad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">psf_pad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">fft_pad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fft_pad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;fill&#39;</span><span class="p">:</span>
        <span class="c1"># create a boundary region at least as large as the kernel</span>
        <span class="k">if</span> <span class="n">psf_pad</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;psf_pad was set to </span><span class="si">{0}</span><span class="s2">, which overrides the &quot;</span>
                          <span class="s2">&quot;boundary=&#39;fill&#39; setting.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">psf_pad</span><span class="p">),</span>
                          <span class="n">AstropyUserWarning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psf_pad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">fft_pad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># default is &#39;True&#39; according to the docstring</span>
            <span class="n">fft_pad</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">psf_pad</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;With boundary=&#39;wrap&#39;, psf_pad cannot be enabled.&quot;</span><span class="p">)</span>
        <span class="n">psf_pad</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">fft_pad</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;With boundary=&#39;wrap&#39;, fft_pad cannot be enabled.&quot;</span><span class="p">)</span>
        <span class="n">fft_pad</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># force zero; it should not be used</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s1">&#39;extend&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;extend&#39; option is not implemented &quot;</span>
                                  <span class="s2">&quot;for fft-based convolution&quot;</span><span class="p">)</span>

    <span class="c1"># find ideal size (power of 2) for fft.</span>
    <span class="c1"># Can add shapes because they are tuples</span>
    <span class="k">if</span> <span class="n">fft_pad</span><span class="p">:</span>  <span class="c1"># default=True</span>
        <span class="k">if</span> <span class="n">psf_pad</span><span class="p">:</span>  <span class="c1"># default=False</span>
            <span class="c1"># add the dimensions and then take the max (bigger)</span>
            <span class="n">fsize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernshape</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># add the shape lists (max of a list of length 4) (smaller)</span>
            <span class="c1"># also makes the shapes square</span>
            <span class="n">fsize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">arrayshape</span> <span class="o">+</span> <span class="n">kernshape</span><span class="p">)))</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fsize</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">psf_pad</span><span class="p">:</span>
            <span class="c1"># just add the biggest dimensions</span>
            <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernshape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">imsh</span><span class="p">,</span> <span class="n">kernsh</span><span class="p">])</span>
                                 <span class="k">for</span> <span class="n">imsh</span><span class="p">,</span> <span class="n">kernsh</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">,</span> <span class="n">kernshape</span><span class="p">)])</span>

    <span class="c1"># perform a second check after padding</span>
    <span class="n">array_size_C</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">*</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">complex_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">byte</span>
    <span class="k">if</span> <span class="n">array_size_C</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">GB</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_huge</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Size Error: Arrays will be </span><span class="si">{}</span><span class="s2">.  Use &quot;</span>
                         <span class="s2">&quot;allow_huge=True to override this exception.&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">human_file_size</span><span class="p">(</span><span class="n">array_size_C</span><span class="p">)))</span>

    <span class="c1"># For future reference, this can be used to predict &quot;almost exactly&quot;</span>
    <span class="c1"># how much *additional* memory will be used.</span>
    <span class="c1"># size * (array + kernel + kernelfft + arrayfft +</span>
    <span class="c1">#         (kernel*array)fft +</span>
    <span class="c1">#         optional(weight image + weight_fft + weight_ifft) +</span>
    <span class="c1">#         optional(returned_fft))</span>
    <span class="c1"># total_memory_used_GB = (np.product(newshape)*np.dtype(complex_dtype).itemsize</span>
    <span class="c1">#                        * (5 + 3*((interpolate_nan or ) and kernel_is_normalized))</span>
    <span class="c1">#                        + (1 + (not return_fft)) *</span>
    <span class="c1">#                          np.product(arrayshape)*np.dtype(complex_dtype).itemsize</span>
    <span class="c1">#                        + np.product(arrayshape)*np.dtype(bool).itemsize</span>
    <span class="c1">#                        + np.product(kernshape)*np.dtype(bool).itemsize)</span>
    <span class="c1">#                        ) / 1024.**3</span>

    <span class="c1"># separate each dimension by the padding size...  this is to determine the</span>
    <span class="c1"># appropriate slice size to get back to the input dimensions</span>
    <span class="n">arrayslices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernslices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">newdimsize</span><span class="p">,</span> <span class="n">arraydimsize</span><span class="p">,</span> <span class="n">kerndimsize</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arrayshape</span><span class="p">,</span> <span class="n">kernshape</span><span class="p">)):</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">newdimsize</span> <span class="o">-</span> <span class="p">(</span><span class="n">newdimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">arrayslices</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">arraydimsize</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
                              <span class="n">center</span> <span class="o">+</span> <span class="p">(</span><span class="n">arraydimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">kernslices</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">kerndimsize</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
                             <span class="n">center</span> <span class="o">+</span> <span class="p">(</span><span class="n">kerndimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">newshape</span> <span class="o">==</span> <span class="n">arrayshape</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
            <span class="n">bigarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">fill_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bigarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
        <span class="n">bigarray</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigarray</span> <span class="o">=</span> <span class="n">array</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">newshape</span> <span class="o">==</span> <span class="n">kernshape</span><span class="p">):</span>
        <span class="n">bigkernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
        <span class="n">bigkernel</span><span class="p">[</span><span class="n">kernslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalized_kernel</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigkernel</span> <span class="o">=</span> <span class="n">normalized_kernel</span>

    <span class="n">arrayfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">bigarray</span><span class="p">)</span>
    <span class="c1"># need to shift the kernel so that, e.g., [0,0,1,0] -&gt; [1,0,0,0] = unity</span>
    <span class="n">kernfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">bigkernel</span><span class="p">))</span>
    <span class="n">fftmult</span> <span class="o">=</span> <span class="n">arrayfft</span> <span class="o">*</span> <span class="n">kernfft</span>

    <span class="n">interpolate_nan</span> <span class="o">=</span> <span class="p">(</span><span class="n">nan_treatment</span> <span class="o">==</span> <span class="s1">&#39;interpolate&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">interpolate_nan</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
            <span class="n">bigimwt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bigimwt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>

        <span class="n">bigimwt</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">nanmaskarray</span> <span class="o">*</span> <span class="n">interpolate_nan</span>
        <span class="n">wtfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">bigimwt</span><span class="p">)</span>

        <span class="c1"># You can only get to this point if kernel_is_normalized</span>
        <span class="n">wtfftmult</span> <span class="o">=</span> <span class="n">wtfft</span> <span class="o">*</span> <span class="n">kernfft</span>
        <span class="n">wtsm</span> <span class="o">=</span> <span class="n">ifftn</span><span class="p">(</span><span class="n">wtfftmult</span><span class="p">)</span>
        <span class="c1"># need to re-zero weights outside of the image (if it is padded, we</span>
        <span class="c1"># still don&#39;t weight those regions)</span>
        <span class="n">bigimwt</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">wtsm</span><span class="o">.</span><span class="n">real</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span>
        <span class="c1"># curiously, at the floating-point limit, can get slightly negative numbers</span>
        <span class="c1"># they break the min_wt=0 &quot;flag&quot; and must therefore be removed</span>
        <span class="n">bigimwt</span><span class="p">[</span><span class="n">bigimwt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigimwt</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fftmult</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="c1"># this check should be unnecessary; call it an insanity check</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Encountered NaNs in convolve.  This is disallowed.&quot;</span><span class="p">)</span>

    <span class="c1"># restore NaNs in original image (they were modified inplace earlier)</span>
    <span class="c1"># We don&#39;t have to worry about masked arrays - if input was masked, it was</span>
    <span class="c1"># copied</span>
    <span class="n">array</span><span class="p">[</span><span class="n">nanmaskarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">kernel</span><span class="p">[</span><span class="n">nanmaskkernel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">fftmult</span> <span class="o">*=</span> <span class="n">kernel_scale</span>

    <span class="k">if</span> <span class="n">return_fft</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fftmult</span>

    <span class="k">if</span> <span class="n">interpolate_nan</span><span class="p">:</span>
        <span class="n">rifft</span> <span class="o">=</span> <span class="p">(</span><span class="n">ifftn</span><span class="p">(</span><span class="n">fftmult</span><span class="p">))</span> <span class="o">/</span> <span class="n">bigimwt</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bigimwt</span><span class="p">):</span>
            <span class="n">rifft</span><span class="p">[</span><span class="n">bigimwt</span> <span class="o">&lt;</span> <span class="n">min_wt</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">if</span> <span class="n">min_wt</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">rifft</span><span class="p">[</span><span class="n">bigimwt</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rifft</span> <span class="o">=</span> <span class="p">(</span><span class="n">ifftn</span><span class="p">(</span><span class="n">fftmult</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">preserve_nan</span><span class="p">:</span>
        <span class="n">rifft</span><span class="p">[</span><span class="n">nanmaskarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="n">crop</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">rifft</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rifft</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="interpolate_replace_nans"><a class="viewcode-back" href="../../../api/astropy.convolution.interpolate_replace_nans.html#astropy.convolution.interpolate_replace_nans">[docs]</a><span class="k">def</span> <span class="nf">interpolate_replace_nans</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">convolve</span><span class="o">=</span><span class="n">convolve</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a data set containing NaNs, replace the NaNs by interpolating from</span>
<span class="sd">    neighboring data points with a given kernel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : `numpy.ndarray`</span>
<span class="sd">        Array to be convolved with ``kernel``.  It can be of any</span>
<span class="sd">        dimensionality, though only 1, 2, and 3d arrays have been tested.</span>
<span class="sd">    kernel : `numpy.ndarray` or `astropy.convolution.Kernel`</span>
<span class="sd">        The convolution kernel. The number of dimensions should match those</span>
<span class="sd">        for the array.  The dimensions *do not* have to be odd in all directions,</span>
<span class="sd">        unlike in the non-fft `convolve` function.  The kernel will be</span>
<span class="sd">        normalized if ``normalize_kernel`` is set.  It is assumed to be centered</span>
<span class="sd">        (i.e., shifts may result if your kernel is asymmetric).  The kernel</span>
<span class="sd">        *must be normalizable* (i.e., its sum cannot be zero).</span>
<span class="sd">    convolve : `convolve` or `convolve_fft`</span>
<span class="sd">        One of the two convolution functions defined in this package.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    newarray : `numpy.ndarray`</span>
<span class="sd">        A copy of the original array with NaN pixels replaced with their</span>
<span class="sd">        interpolated counterparts</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">newarray</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">convolved</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">nan_treatment</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">,</span>
                         <span class="n">normalize_kernel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">isnan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">newarray</span><span class="p">[</span><span class="n">isnan</span><span class="p">]</span> <span class="o">=</span> <span class="n">convolved</span><span class="p">[</span><span class="n">isnan</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">newarray</span></div>


<div class="viewcode-block" id="convolve_models"><a class="viewcode-back" href="../../../api/astropy.convolution.convolve_models.html#astropy.convolution.convolve_models">[docs]</a><span class="k">def</span> <span class="nf">convolve_models</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;convolve_fft&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve two models using `~astropy.convolution.convolve_fft`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : `~astropy.modeling.core.Model`</span>
<span class="sd">        Functional model</span>
<span class="sd">    kernel : `~astropy.modeling.core.Model`</span>
<span class="sd">        Convolution kernel</span>
<span class="sd">    mode : str</span>
<span class="sd">        Keyword representing which function to use for convolution.</span>
<span class="sd">            * &#39;convolve_fft&#39; : use `~astropy.convolution.convolve_fft` function.</span>
<span class="sd">            * &#39;convolve&#39; : use `~astropy.convolution.convolve`.</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        Keyword arguments to me passed either to `~astropy.convolution.convolve`</span>
<span class="sd">        or `~astropy.convolution.convolve_fft` depending on ``mode``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    default : CompoundModel</span>
<span class="sd">        Convolved model</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;convolve_fft&#39;</span><span class="p">:</span>
        <span class="n">BINARY_OPERATORS</span><span class="p">[</span><span class="s1">&#39;convolve_fft&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">convolve_fft</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;convolve&#39;</span><span class="p">:</span>
        <span class="n">BINARY_OPERATORS</span><span class="p">[</span><span class="s1">&#39;convolve&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_make_arithmetic_operator</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">convolve</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Mode </span><span class="si">{}</span><span class="s1"> is not supported.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">_CompoundModelMeta</span><span class="o">.</span><span class="n">_from_operator</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011-2016, The Astropy Developers.<br/>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.5.6. &nbsp;
    Last built 05 Jul 2017. <br/>
  </p>
</footer>
  </body>
</html>